# -*- coding: utf-8 -*-
"""1D Target Search.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TiO_aNaWbesjEuq7wi3Xu4hk5XIiSn91
"""

import numpy as np
import random
import matplotlib.pyplot as plt


N = 10000   #Number of walkers
L = 10   #Total space
T = 10000    #time steps
x_0 = 0   #Initial position
dx = 1    # step size
a = .5    # persistance level



Vmatrix = np.zeros((T, N)) # velocity matrix
Xmatrix = np.zeros((T, N)) # position matrix

target_loc = L - 1  # choose target location here
print(f"target location: {target_loc}")
'''
def vinitial():   # chooses initial velocity
  r = random.random()
  if r > .5:
    return 1
  else:
    return -1
'''
'''
# equal number of v_initial directions
def vinitial(i):
  if (i) % 2 == 0:
    return 1
  else:
    return -1
'''

def vinitial(i):
  up = 1
  down = -1
  return down # choose initial velocity




def v_t(prev_v): # determine new v
  r = random.random()
  if r < a:
    v = prev_v
  else:
    v = -prev_v

  return v




def x_pos(pos_i):
    fpt = np.zeros(N) # first passage times
    for n in range(N):
        x = int(pos_i)
        Xmatrix[0, n] = x # set initial position

        v = vinitial(n)
        Vmatrix[0, n] = v #initialize initial velocity

        for t in range(1, T):


            v = np.array(v_t(Vmatrix[t-1,n])) #assign velocities
            Vmatrix[t, n] = v

            step = v * dx

            x = x + step # position update


            if x >= L:  # periodic boundary conditions
                x -= L
            elif x < 0:
                x += L

            Xmatrix[t, n] = x # assign new positions

            if x == target_loc: # check to see if walker has hit target
                fpt[n] = t # fill array with first passage times
                break
    return fpt



fig, (plot1, plot2) = plt.subplots(1, 2, figsize=(15, 4)) # subplots

# calculate mfpt to (target_loc) for N walkers from a single point (x_0)
fpt = x_pos(x_0)
fpt = fpt[fpt > 0]



mfptY = np.sum(fpt / N) # mean from all fpts / N
print(f"MFPT:{mfptY} from x_0 = {x_0}")
print(f"{len(fpt)} walkers reached the target out of {N}")

#mfpt = np.mean(fpt) # mean from numpy
#print(f"MFPT:{mfpt} from x_0 = {x_0}")


###### Histogram ######
plot1.hist(fpt, bins = 150, edgecolor = 'black', density = True)
plot1.set_title(f"fpts from x = {x_0}")
plot1.set_ylabel("first passage time probability distribution")
plot1.set_xlabel("First Passage Time (t)")
#######################


# idea for equilibration problem, doesnt work with target search very well in this code
'''
t = 7
Peq = np.zeros(L)
Peq = Xmatrix[t,:]
plot2.hist(Peq, bins = 150, edgecolor = 'black', density = True)
print(Peq)
'''











############## GLOBAL MFPT #################
# calculate MFPT for whatever 'a' value is set above
FPTS = []
for i in range(L):
  if i == target_loc:  # skip target
    continue

  fpt = x_pos(i)
  fpt = fpt[fpt > 0]
  FPTS.extend(fpt)



MFPTSY = np.mean(FPTS)
print(f"MFPT over all positions:{MFPTSY} with {len(FPTS)} walkers that made it out of {(L - 1) * N}")


x_start = 0


# calculating mfpt for diff positions

all_MFPTS = []

for x_start in range(L):
    fpt = x_pos(x_start)
    fpt = fpt[fpt > 0]
    MFPT = np.mean(fpt)
    all_MFPTS.append((x_start, MFPT))

all_MFPTS = np.array(all_MFPTS)
plot2.scatter(all_MFPTS[:, 0], all_MFPTS[:, 1])
plot2.set_xlabel("initial position")
plot2.set_ylabel("MFPT")
plot2.set_title("MFPT(x)")
plot2.axvline(target_loc, color = 'r', linestyle = '--')





fig, (plot3, plot4) = plt.subplots(1, 2, figsize=(15, 4)) # 2nd set of subplots

################################
#     Theoretical MFPT

T_matrix = np.zeros((2*L,1))    #MFPT vector
for i in range(L):
  T_matrix[i] = i
  T_matrix[i+L] = i
T_matrix[target_loc] =  0
T_matrix[target_loc+L] =  0

#print(T_matrix)


trans_matrix = np.zeros((2*L, 2*L))
for l in range(L):
  trans_matrix[l,(l+1) % L] = a   # +x (top left)
  trans_matrix[(l+1) % L,l + L] = (1 - a)   # -x (top right)    switch direction
  trans_matrix[l + L,(l+1) % L] = (1 - a)   # +x (bottom left)   switch direction
  trans_matrix[(l+1) % L + L,l + L] = a   # -x (bottom right)
trans_matrix[target_loc,:] = 0
trans_matrix[target_loc+L,:] = 0


#print(trans_matrix)

A_vector = np.ones((2 * L, 1))
A_vector[target_loc] = 0
A_vector[target_loc+L] = 0

#print(A_vector)



#T_matrix = trans_matrix @ T_matrix + A_vector

#print(T_matrix)


I = np.eye(2 * L)



T_matrix = np.linalg.solve(I - trans_matrix, A_vector)
T_matrix[target_loc] = L    #Kac theorum
T_matrix[target_loc+L] = L    #Kac Theorum
print(T_matrix)





plot3.scatter(range(L), T_matrix[0:L])
plot3.set_xlabel("position")
plot3.set_ylabel("MFPT")
plot3.set_title("theoretical MFPT(x) with v_initial = -1")

plot3.scatter(all_MFPTS[:, 0], all_MFPTS[:, 1])
plot3.axvline(target_loc, color = 'r', linestyle = '--')
plot3.legend(["theoretical", "simulated"])


plot4.scatter(range(L), T_matrix[L:L * 2])
plot4.set_xlabel("position")
plot4.set_ylabel("MFPT")
plot4.set_title("theoretical MFPT(x) with v_initial = +1")





'''
# MFPT(a) graph
all_mfpts = []
while a <= 1:
  all_fpts = []
  for i in range(L):
    if i == target_loc:  # skip target
      continue

    fpt = x_pos(i)
    fpt = fpt[fpt > 0]
    all_fpts.extend(fpt)

  MFPT = np.mean(all_fpts)

  all_mfpts.append(MFPT)

  for n in range(len(all_mfpts)):
    y = all_mfpts[n] / all_mfpts[0]
  x = a


  plot3.scatter(x,y)

  plot3.set_xlabel("a")
  plot3.set_ylabel("MFPT / MFPT_0")
  plot3.set_title("1D MFPT(a)")

  a += .01
'''

plt.show()