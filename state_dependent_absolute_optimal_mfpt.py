# -*- coding: utf-8 -*-
"""state-dependent absolute optimal MFPT

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10ejxxwaNls-JzMhF0RPXhfVgTx94anBy
"""

####################### MDP ON ALL STATES
import numpy as np
import random
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import math as m

from scipy.sparse import lil_matrix
from scipy.sparse import identity
from scipy.sparse.linalg import spsolve

fig, (plot1, plot2) = plt.subplots(1, 2, figsize=(15, 4)) # subplots


L = 10
T_max = 1000
coordinates = np.arange(L) # creates array from 0 to L
Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows


target_loc = pos_matrix[L // 2,L // 2]

# Create transition matrix functions

def coord_to_index(i,j,k):
  M = L**2
  if k == 0:
    return j + i * L
  elif k == 1:
    return j + i * L + M
  elif k == 2:
    return j + i * L + 2 * M
  else:
    return j + i * L + 3 * M


def k_prime(k, l):
  if l == 0:
    return k
  elif l == 1:
    if k == 0:
      return 1
    elif k == 1:
      return 0
    elif k == 2:
      return 3
    else:
      return 2

  elif l == 2:
    if k ==0:
      return 2
    elif k == 1:
      return 3
    elif k == 2:
      return 1
    else:
      return 0

  elif l == 3:
    if k == 0:
      return 3
    elif k == 1:
      return 2
    elif k == 2:
      return 0
    else:
      return 1

def create_M_matrix(p1, p2, p3, p4):
    M_matrix = lil_matrix((L**2 * 4, L**2 * 4))
    probs = [p1, p2, p3, p4]
    direction_vectors = {
        0: (0, 1),   #dj = +1
        1: (0, -1),  #dj = -1
        2: (1, 0),   #di = +1
        3: (-1, 0)   #di = -1
    }
    for i in range(L):
        for j in range(L):
            for k in range(4):
                index = coord_to_index(i, j, k)   # find initial index

                #if [i, j] == target_loc:
                if [i, j] == list(target_loc):  # zero out target loc rows
                   continue
                for l in range(4):
                  prob = probs[l]       #choose probability
                  new_k = k_prime(k,l)    #find new velocities
                  di, dj = direction_vectors[new_k]     # find new direction change
                  ni, nj = (i + di) % L, (j + dj) % L   # update position
                  next_index = coord_to_index(ni, nj, new_k)    #convert back to index
                  M_matrix[index, next_index] = prob     #fill matrix with prob to go from (i, j, k) to (i', j', k')
    return M_matrix.tocsr()

### MDP

target_indices = []
for k in range(4):
  target_indices.append(coord_to_index(target_loc[0], target_loc[1], k))

V = np.zeros((T_max + 1, L**2 * 4))   # value function initialization
V[:, target_indices] = 0

mu_0 = np.ones(L**2 * 4)
mu_0[target_indices] = 0
mu_0 = mu_0 / np.sum(mu_0) # inital state
#print(mu_0)


# Backward Recursion
best_p1 = np.zeros((T_max,L**2 * 4))
p1_values = np.linspace(0, 1, 500) # CHOOSE HERE WHICH P1 VALUES TO USE IN P1(T)     # (lower bound, upper bound, number of divisions)


M_matrices = {}  # Store M matrices for each p1 value
for p1 in p1_values:
    p234 = (1 - p1) / 3
    M_matrices[p1] = create_M_matrix(p1, p234, p234, p234)


one_vector = np.ones(L**2 * 4)
one_vector[target_indices] = 0    # skip target state???


##################### Value iteration of bellman equation
for t in reversed(range(T_max)):

  for s in range(L**2 * 4):
    best_cost = 1e9
    if s in target_indices:
      continue

    for p1 in p1_values:
      M = M_matrices[p1]


      #Q[s] = one_vector + (M @ V[t + 1].reshape(-1, 1)).flatten()      # Bellman equation iteration
      Q = one_vector + M @ V[t + 1]


      E_T = Q[s]



      if E_T < best_cost: # Minimization, find the minimum expected MFPT
          best_cost = E_T   # set best cost to expected cost to compare different expected MFPT(p1)
          V[t,s] = Q[s]  # Update V[t] with the Q that gives the minimum cost
          best_p1[t,s] = p1 # sets best_p1 with the p1 which gives the minimum expected cost
          #print(best_cost)


def find_fpt(state_index):
    return mu_0[state_index] * V[0, state_index]






def find_prob_mass():
  mu_t = np.zeros((T_max, L**2 * 4))
  mu_t[0] = mu_0
  mu_t_sum = []

  for t in range(1,T_max):
    mu_ttt = mu_t[t,:] * V[t,:]
    mu_t[t] = mu_ttt
    mu_t_sum.append(np.sum(mu_ttt))


  return mu_t_sum

probmass = find_prob_mass()
#print(probmass)


plt.figure(figsize=(8, 8))
plt.plot(probmass, label = 'probs in transient states')















MFPT_list = []
for i in range(L):
  for j in range(L):
    for k in range(4):

      MFPT_list.append(find_fpt(coord_to_index(i, j, k)))


MFPT = np.mean(MFPT_list)
print("MFPT:", MFPT)


avg_p1t = np.zeros(T_max)
for t in range(T_max):
    avg_p1t[t] = np.mean(best_p1[t])    # average over p1(t,s) for p1(t)




plot1.plot(avg_p1t)
plot1.set_xlabel("Time step")
plot1.set_ylabel("Optimal p1")
plot1.set_title("Optimal Control p1(t) Over Time")


def find_best_prob(i, j, k):
    directions = {0: (0, 1), 1: (0, -1), 2: (1, 0), 3: (-1, 0)}
    move = best_p1[0, coord_to_index(i, j, k)]
    return directions[k] if move > 0.5 else directions[k_prime(k, 1)]





Is = np.zeros((L, L))
Js = np.zeros((L, L))

p1_s_map = np.zeros((L, L))

for i in range(L):
    for j in range(L):
        best_fpt = np.inf
        for k in range(4):
            idx = coord_to_index(i, j, k)
            fpt = find_fpt(idx)
            if fpt < best_fpt:
                best_fpt = fpt
                p1_s_map[i, j] = fpt
                dx, dy = find_best_prob(i, j, k)
                Is[i, j] = dx
                Js[i, j] = dy

        if (i, j) == (target_loc[0], target_loc[1]):
            Is[i, j] = 0
            Js[i, j] = 0







#plt.figure(figsize=(8, 8))
plt.imshow(p1_s_map.T, origin='lower', cmap='viridis', extent=[0, L, 0, L])
plt.colorbar(label='Minimum FPT')
plt.quiver(np.arange(L) + .5, np.arange(L) + .5, Is.T, Js.T, color='black')
plt.scatter(target_loc[0] + .5,target_loc[1] + .5, c='red',marker='X', label='Target')
plt.title("Optimal Paths to Target")
plt.legend()



p1_s = np.zeros(T_max)
p1_s = best_p1[0]
#print(p1_s)



plt.show()

import numpy as np
import random
import matplotlib.pyplot as plt


##################################################### STOCHASTIC SIMULATION FOR best_p1 values
#T_max = new_T_max
N = 1000  #Number of walkers
dx = 1      #step space
T_max = 2500

def a(t):
  if t < 1000:
    a = avg_p1t[t]
  else:
    a = 0.47
  return a




coordinates = np.arange(L) # creates array from 0 to L
Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows


target_loc = pos_matrix[L // 2,L // 2] # choose target location


Xmatrix = np.zeros((T_max, N, 2))  # (x, y) position matrix
Vmatrix = np.zeros((T_max, N, 2))  # (vx, vy) velocity matrix

# transformation matrices
a_matrix = np.array([[1,0],[0,1]]) # forward
b_matrix = np.array([[-1,0],[0,-1]]) # backward
c_matrix = np.array([[0,-1],[1,0]]) # left
d_matrix = np.array([[0,1],[-1,0]]) # right

# random vinitial function
'''
def vinitial(i):   # chooses initial velocity
  r = random.choice([[0,1],[0,-1],[1,0],[-1,0]])
  return r
'''

'''
#possible tejedor vinitial function?
def vinitial(i):
  if (i) % 4 == 0:
    return np.array([1,0])
  elif (i) % 4 == 1:
    return np.array([-1,0])
  elif (i) % 4 == 2:
    return np.array([0,1])
  else:
    return np.array([0,-1])
'''


# choose initial velocity
def vinitial(i):
  if i == 0:
    d = np.array([1,0]) # +x
  elif i == 1:
    d = np.array([-1,0]) # -x
  elif i == 2:
    d = np.array([0,1]) # +y
  elif i == 3:
    d = np.array([0,-1]) # -y
  return d





# velocity update version 3 (tejedor)
def v_t(prev_v, p_1):
    r = random.random()

    p_2 = (1 - p_1)/3
    p_3 = p_2



    if r < p_1:
      R = a_matrix  # move forward
    elif r < p_1 + p_2:
      R = b_matrix  # move backward
    elif  r < p_1 + p_2 + p_3:
      R = c_matrix  # turn left
    else:
      R = d_matrix  # turn right

    v = R @ np.array(prev_v)
    return v




# position update function
def x_pos(pos_i):
    fpt = np.zeros(N) # intitialize first passage times array
    for n in range(N):
        x = np.array(pos_i)
        Xmatrix[0, n] = x # set initial position

        v = np.array(vinitial(0))
        Vmatrix[0, n] = v #initialize initial velocity

        for t in range(1, T_max):

            p1 = a(t)

            v = np.array(v_t(Vmatrix[t-1,n], p1)) #assign velocities
            Vmatrix[t, n] = v

            step = v * dx

            x = x + step # position update
            x = x % L # boundary condition

            Xmatrix[t, n] = x # assign new positions

            if np.array_equal(Xmatrix[t,n], target_loc): # check to see if walker has hit target
                fpt[n] = t # fill array with first passage times
                break # stop the random walk

    return fpt








# run trajectories over all starting positions

mfpt_map = np.zeros([L, L])
all_fpt = []  # initialize list for all FPTs
fptpos = np.zeros([N, L, L])  # store FPTs for each walker at each initial position

for i in range(L):  # x
    for j in range(L):  # y
        start_pos = pos_matrix[i, j]

        if np.array_equal(start_pos, target_loc):  # skip target
            continue

        fpt = x_pos(start_pos)  # run walkers
        fpt = fpt[fpt > 0]  # remove zero (non-hits)

        all_fpt.extend(fpt)  # accumulate valid FPTs


        if len(fpt) == N:
          fptpos[:, i, j] = fpt
          mfpt_map[i,j] = np.mean(fpt)



fig, (plot1, plot2) = plt.subplots(1, 2, figsize=(15, 4)) # subplots



#trajectory plots

'''
for n in range(N):
    plot1.plot(Xmatrix[:, n, 0], Xmatrix[:, n, 1])
plot1.grid(True)
'''

MFPT = np.sum(all_fpt) / (L**2  * N) #calculate mean first passage time over all positions and walkers
'''
alist = []
for t in range(50):
  alist.append(a(t))
plot2.plot(range(len(result.inputs.T)), alist)
'''

print(f"MFPT: {MFPT}")
print(f"{len(all_fpt)} out of {N * (L**2-1)} walkers found target")

'''
plot1.imshow(mfpt_map.T)
plot1.colorbar(label='MFPT')
plot1.scatter(*target_loc, color='red')
'''

plt.show()

############ ANALYTICAL OPTIMAL MFPT LOWER BOUND

import numpy as np
import random
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import math as m

from scipy.sparse import lil_matrix
from scipy.sparse import identity
from scipy.sparse.linalg import spsolve

#fig, (plot1, plot2) = plt.subplots(1, 2, figsize=(15, 4)) # subplots


L = 12
T_max = 300
coordinates = np.arange(L) # creates array from 0 to L
Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows


target_loc = pos_matrix[L//2,L//2]




def coord_to_index(i,j,k):
  M = L**2
  if k == 0:
    return j + i * L
  elif k == 1:
    return j + i * L + M
  elif k == 2:
    return j + i * L + 2 * M
  else:
    return j + i * L + 3 * M







target_indices = []
for k in range(4):
  target_indices.append(coord_to_index(target_loc[0], target_loc[1], k))

def find_time(pos_i):


  dx = abs(target_loc[0] - pos_i[0])
  dy = abs(target_loc[1] - pos_i[1])

  x_distance = min(dx, L - dx)
  y_distance = min(dy, L - dy)

  return x_distance, y_distance




def find_best_move(pos):    # best initial move (for arrows)

  directions = {1: (0, 1), 2: (0, -1), 3: (1, 0), 4: (-1, 0)}

  min_dist = 1e9
  best_move = (0, 0)

  for i in directions.values():
      new_pos = ((pos[0] + i[0]) % L, (pos[1] + i[1]) % L)
      d = np.sum(find_time(new_pos))
      if d < min_dist:
          min_dist = d
          best_move = i

  return best_move




time_map = np.zeros((L, L))
I = np.zeros((L, L))
J = np.zeros((L, L))

# Compute values
for i in range(L):
    for j in range(L):
        pos = (i, j)
        time_map[i, j] = np.sum(find_time(pos))
        dx, dy = find_time(pos)


        dx, dy = find_best_move(pos)
        I[i, j] = dx
        J[i, j] = dy

        if pos == (target_loc[0], target_loc[1]):
            I[i, j] = 0
            J[i, j] = 0



mfpt = np.sum(time_map) / (L**2 - 1)
print("MFPT:", mfpt)

#plt.figure(figsize=(8, 8))
plt.imshow(time_map, origin='lower', extent=[0, L, 0, L])
plt.colorbar(label='Minimum FPT')
plt.quiver(np.arange(L) + .5, np.arange(L) + .5, I.T, J.T, color='black')
plt.scatter(target_loc[0] + .5,target_loc[1] + .5, c='red',marker='X', label='Target')
plt.title("Optimal Paths to Target")
plt.legend()



plt.show()