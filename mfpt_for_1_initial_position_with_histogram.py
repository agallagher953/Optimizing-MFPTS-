# -*- coding: utf-8 -*-
"""MFPT for 1 initial position with histogram.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R0cqbQRjUlMLzF0ptexSZceD4c9xszvH
"""

import numpy as np
import random
import matplotlib.pyplot as plt


N = 100  #Number of walkers
L = 10   # Length of lattice
T = 1000   #time steps
dx = 1      #step space
#a = .5      # persistence level
p_1 = .25    # prob to go forwards
p_2 = .25    # prob to go backwards
p_3 = .25    # prob to turn left
p_4 = .25    # prob to turn right



coordinates = np.arange(L) # creates array from 0 to L
Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows


target_loc = pos_matrix[5,5] # choose target location


Xmatrix = np.zeros((T, N, 2))  # (x, y) position matrix
Vmatrix = np.zeros((T, N, 2))  # (vx, vy) velocity matrix

# transformation matrices
a_matrix = np.array([[1,0],[0,1]]) # forward
b_matrix = np.array([[-1,0],[0,-1]]) # backward
c_matrix = np.array([[0,-1],[1,0]]) # left
d_matrix = np.array([[0,1],[-1,0]]) # right

# random vinitial function
'''
def vinitial(i):   # chooses initial velocity
  r = random.choice([[0,1],[0,-1],[1,0],[-1,0]])
  return r
'''
#possible tejedor vinitial function?
def vinitial(i):
  if (i+4) % 4 == 0:
    return np.array([1,0])
  elif (i+4) % 4 == 1:
    return np.array([-1,0])
  elif (i+4) % 4 == 2:
    return np.array([0,1])
  else:
    return np.array([0,-1])


# choose initial velocity
'''
def vinitial(i):
  r = np.array([1,0]) # right
  l = np.array([-1,0]) # left
  u = np.array([0,1]) # up
  d = np.array([0,-1]) # down
  return r
'''


# version 3 (tejedor)

def v_t(prev_v):
    r = random.random()
    if r < p_1:
      R = a_matrix  # move forward
    elif r < p_1 + p_2:
      R = b_matrix  # move backward
    elif  r < p_1 + p_2 + p_3:
      R = c_matrix  # turn left
    else:
      R = d_matrix  # turn right

    v = R @ np.array(prev_v)
    return v


# position update function
def x_pos(pos_i):
    fpt = np.zeros(N) # intitialize first passage times array
    for n in range(N):
        x = np.array(pos_i)
        Xmatrix[0, n] = x # set initial position

        v = np.array(vinitial(n))
        Vmatrix[0, n] = v #initialize initial velocity

        for t in range(1, T):

            v = np.array(v_t(Vmatrix[t-1,n])) #assign velocities
            Vmatrix[t, n] = v

            step = v * dx

            x = x + step # position update
            x = x % L # boundary condition

            Xmatrix[t, n] = x # assign new positions

            if np.array_equal(Xmatrix[t,n], target_loc): # check to see if walker has hit target
                fpt[n] = t # fill array with first passage times
                break # stop the random walk

    return fpt


# run trajectories over all starting positions

all_fpt = [] # initialize list for all FPTs


for i in range(L):  # x
    for j in range(L):  # y
        start_pos = pos_matrix[i, j]

        if np.array_equal(start_pos, target_loc):  # skip target
            continue

        fpt = x_pos(start_pos)  # run walkers
        fpt = fpt[fpt > 0]  # remove zero (non-hits)

        all_fpt.extend(fpt)  # accumulate valid FPTs









'''
for i in range(L): #x
    for j in range(L): #y
        start_pos = pos_matrix[i, j]

        if np.array_equal(start_pos, target_loc): # check if starting position is the target location
            continue  # skip target

        fpt = x_pos(start_pos) # calculate FPTs and fill array for each position

        fpt = fpt[fpt > 0] # only fill list with real FPTs
        all_fpt.extend(fpt) # add all the FPTs to all_fpt list
'''
MFPT = np.mean(all_fpt) #calculate mean first passage time over all positions and walkers
print(f"MFPT: {MFPT}")

print(f"{len(all_fpt)} out of {N} walker found target")
#print(f"{len(all_fpt)} out of {N * (L**2-1)} walkers found target")




plt.hist(all_fpt, bins=300,  range=(0, T), edgecolor='black', density = True)
plt.xlabel("Time (t)")
plt.ylabel("P(t)")

plt.show()