# -*- coding: utf-8 -*-
"""control systems p1(t) optimization for unique probabilities.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tOUuMaLz9LW9oFNFFj8vhPGJ4seC5dan
"""

import numpy as np
import random
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import math as m

from scipy.sparse import lil_matrix
from scipy.sparse import identity
from scipy.sparse.linalg import spsolve
from scipy.sparse import lil_matrix, csr_matrix, vstack, hstack, identity


!pip install control
import control as ct
import control.optimal as opt

L = 5
T_max = 50
coordinates = np.arange(L) # creates array from 0 to L
Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows


target_loc = pos_matrix[L // 2,L // 2]

# Create transition matrix functions

def coord_to_index(i,j,k):
  M = L**2
  if k == 0:
    return j + i * L
  elif k == 1:
    return j + i * L + M
  elif k == 2:
    return j + i * L + 2 * M
  else:
    return j + i * L + 3 * M


def k_prime(k, l):
  if l == 0:
    return k
  elif l == 1:
    if k == 0:
      return 1
    elif k == 1:
      return 0
    elif k == 2:
      return 3
    else:
      return 2

  elif l == 2:
    if k ==0:
      return 2
    elif k == 1:
      return 3
    elif k == 2:
      return 1
    else:
      return 0

  elif l == 3:
    if k == 0:
      return 3
    elif k == 1:
      return 2
    elif k == 2:
      return 0
    else:
      return 1

def create_M_matrix(p1, p2, p3, p4):
    M_matrix = lil_matrix((L**2 * 4, L**2 * 4))
    probs = [p1, p2, p3, p4]
    direction_vectors = {
        0: (0, 1),   #dj = +1
        1: (0, -1),  #dj = -1
        2: (1, 0),   #di = +1
        3: (-1, 0)   #di = -1
    }
    for i in range(L):
        for j in range(L):
            for k in range(4):
                index = coord_to_index(i, j, k)   # find initial index

                #if [i, j] == target_loc:
                if [i, j] == list(target_loc):  # zero out target loc rows
                   continue
                for l in range(4):
                  prob = probs[l]       #choose probability
                  new_k = k_prime(k,l)    #find new velocities
                  di, dj = direction_vectors[new_k]     # find new direction change
                  ni, nj = (i + di) % L, (j + dj) % L   # update position
                  next_index = coord_to_index(ni, nj, new_k)    #convert back to index
                  M_matrix[index, next_index] = prob     #fill matrix with prob to go from (i, j, k) to (i', j', k')



    return M_matrix.tocsr()


target_indices = []
for k in range(4):
  target_indices.append(coord_to_index(target_loc[0], target_loc[1], k))


mu_0 = np.ones(L**2 * 4)
mu_0[target_indices] = 0
mu_0 = mu_0 / np.sum(mu_0)



def markov_update(t, x, u, params):
    p1, p2, p3, p4 = u
    P = create_M_matrix(p1, p2, p3, p4)
    return P @ x




def f_update(t, x, u, params):
    u = np.clip(u, 1e-6, 1)
    u = u / np.sum(u)
    return markov_update(t, x, u, params)

def f_output(t, x, u, params):
    return x

system = ct.NonlinearIOSystem(
    f_update,
    f_output,
    states=L**2 * 4,
    inputs=4,
    name="markov",
    dt = 1.0
)

def cost_func(x, u):
    return np.sum(x)


def terminal_cost(x, u):
    return 0



constraints = [
    opt.input_range_constraint(system, [0, 0, 0, 0], [1, 1, 1, 1])
]


dt = 1

Tf = T_max
timepts = np.arange(0, Tf + dt, dt)

u0 = np.ones((4, len(timepts))) * 0.5


result = opt.solve_optimal_trajectory(
    system,
    timepts,
    mu_0,
    cost_func,
    constraints=constraints,
    terminal_cost=terminal_cost,
    initial_guess=u0,
)








plt.plot(result.time, result.inputs.T)
plt.title("Optimal Probabilities Over Time")
plt.xlabel("Time")
plt.ylabel("Probabilities")
plt.legend(["p1(t)", "p2(t)", "p3(t)", "p4(t)"])




resp = ct.input_output_response(
    system,
    timepts,
    result.inputs,
    X0=mu_0,
    evaluation_times=timepts,
)






t = resp.time
mu_traj = resp.outputs
mu_traj = mu_traj.T
u_traj = resp.inputs  # your control sequence p1, p2, p3, p4



total_prob = [np.sum(mu) for mu in mu_traj]
plt.plot(t, total_prob)
plt.title("Total Probability Mass Over Time")
plt.xlabel("Time")
plt.ylabel("Sum Over All Transient States")
plt.show()


plt.show()

fig, (plot1, plot2) = plt.subplots(1, 2, figsize=(15, 4)) # subplots

max_iters = 3
tol = 1e-3
prev_cost = np.inf
u0 = result.inputs


for i in range(max_iters):
    result = opt.solve_optimal_trajectory(
        system, timepts, mu_0, cost_func,
        constraints=constraints,
        terminal_cost=terminal_cost,
        initial_guess=u0
    )
    print(f"Iter {i+1}, cost: {result.cost}")

    if np.abs(prev_cost - result.cost) < tol:
        print("Converged.")
        break

    prev_cost = result.cost
    u0 = result.inputs








plot1.plot(result.time, result.inputs.T)
plot1.set_title("Optimized p1(t) over time")
plot1.set_xlabel("Time")
plot1.set_ylabel("p1(t)")






resp = ct.input_output_response(
    system,
    timepts,
    result.inputs,
    X0=mu_0,
    evaluation_times=timepts,
)








t = resp.time
mu_traj = resp.outputs
mu_traj = mu_traj.T


u_traj = resp.inputs


################# plot prob mass for time-varying control
total_prob = [np.sum(mu) for mu in mu_traj]
plot2.plot(t, total_prob, label = 'Time-Varying p1')
plot2.set_title("Total Probability Mass Over Time")
plot2.set_xlabel("Time")
plot2.set_ylabel("Sum Over All Transient States")
plot2.legend()







############### plot prob mass for static p1

def find_mass(p):
  p2 = (1 - p) / 3
  M = create_M_matrix(p, p2, p2, p2)
  mu_t = np.zeros((T_max+1, L**2 * 4))
  mu_t[0] = mu_0
  mu_sums = []
  mu_sums.append(np.sum(mu_0))
  for t in range(T_max - 1):
    mu_ttt = M @ mu_t[t]
    mu_t[t+1] = mu_ttt

    mu_sum = np.sum(mu_ttt)

    mu_sums.append(mu_sum)
  return mu_sums


mus = find_mass((0.47967390338107563))          # call function
plot2.plot(range(T_max), mus, label = 'Static p1')
plot2.legend()







################################################ calculating REAL MFPT using fundamental matrix
def create_Q_matrix(p1, p2, p3, p4):
    M = create_M_matrix(p1, p2, p3, p4)



    transient_indices = []
    for i in range(L**2 * 4):
      if i not in target_indices:
        transient_indices.append(i)

    reordered_indices = transient_indices + target_indices
    #print(reordered_indices)

    M_reordered = M[reordered_indices, :][:, reordered_indices]


    t_len = len(transient_indices)
    Q = M_reordered[:t_len, :t_len]

    return Q.tocsr()




def find_time(p_policy):

  Q_matrices = {}

  for t in range(T_max):


    Q_matrices[t] = create_Q_matrix(p_policy[t,0],p_policy[t,1] ,p_policy[t,2],p_policy[t,3])


  I = identity(L**2 * 4 - 4).tocsr()
  N = I.copy()
  Q_power = Q_matrices[0]
  for t in range(1, T_max):
     N += Q_power
     Q_power = Q_power @ Q_matrices[t]


  c = np.ones((L**2 * 4 - 4, 1))
  mfpt = N @ c
  meantime = np.sum(mfpt) / (L**2 * 4)

  return meantime



MFPT = find_time(result.inputs.T)
print("TRUE MFPT:", MFPT)


plt.show()

import numpy as np
import random
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import math as m

from scipy.sparse import lil_matrix
from scipy.sparse import identity
from scipy.sparse.linalg import spsolve
from scipy.sparse import lil_matrix, csr_matrix, vstack, hstack, identity


T_max = 50
coordinates = np.arange(L) # creates array from 0 to L
Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows


target_loc = pos_matrix[L // 2,L // 2]

# Create transition matrix functions

def coord_to_index(i,j,k):
  M = L**2
  if k == 0:
    return j + i * L
  elif k == 1:
    return j + i * L + M
  elif k == 2:
    return j + i * L + 2 * M
  else:
    return j + i * L + 3 * M


def k_prime(k, l):
  if l == 0:
    return k
  elif l == 1:
    if k == 0:
      return 1
    elif k == 1:
      return 0
    elif k == 2:
      return 3
    else:
      return 2

  elif l == 2:
    if k ==0:
      return 2
    elif k == 1:
      return 3
    elif k == 2:
      return 1
    else:
      return 0

  elif l == 3:
    if k == 0:
      return 3
    elif k == 1:
      return 2
    elif k == 2:
      return 0
    else:
      return 1

def create_M_matrix(p1, p2, p3, p4):
    M_matrix = lil_matrix((L**2 * 4, L**2 * 4))
    probs = [p1, p2, p3, p4]
    direction_vectors = {
        0: (0, 1),   #dj = +1
        1: (0, -1),  #dj = -1
        2: (1, 0),   #di = +1
        3: (-1, 0)   #di = -1
    }
    for i in range(L):
        for j in range(L):
            for k in range(4):
                index = coord_to_index(i, j, k)   # find initial index

                #if [i, j] == target_loc:
                if [i, j] == list(target_loc):  # zero out target loc rows
                   continue
                for l in range(4):
                  prob = probs[l]       #choose probability
                  new_k = k_prime(k,l)    #find new velocities
                  di, dj = direction_vectors[new_k]     # find new direction change
                  ni, nj = (i + di) % L, (j + dj) % L   # update position
                  next_index = coord_to_index(ni, nj, new_k)    #convert back to index
                  M_matrix[index, next_index] = prob     #fill matrix with prob to go from (i, j, k) to (i', j', k')



    return M_matrix.tocsr()


target_indices = []
for k in range(4):
  target_indices.append(coord_to_index(target_loc[0], target_loc[1], k))




def M_to_canonical_form(p1,p2,p3,p4):
    M = create_M_matrix(p1, p2, p3, p4)


    transient_indices = []
    for i in range(L**2 * 4):
      if i not in target_indices:
        transient_indices.append(i)

    reordered_indices = transient_indices + target_indices
    #print(reordered_indices)

    M_reordered = M[reordered_indices, :][:, reordered_indices]

    t_len = len(transient_indices)
    a_len = len(target_indices)


    Q = M_reordered[:t_len, :t_len]
    R = M_reordered[:t_len, t_len:]
    zero_block = lil_matrix((a_len, t_len))
    identity_block = identity(a_len)

    top = hstack([Q, R])
    bottom = hstack([zero_block, identity_block])
    canonical = vstack([top, bottom])

    return canonical.tocsr()




def create_Q_matrix(p1, p2, p3, p4):
    M = create_M_matrix(p1, p2, p3, p4)



    transient_indices = []
    for i in range(L**2 * 4):
      if i not in target_indices:
        transient_indices.append(i)

    reordered_indices = transient_indices + target_indices
    #print(reordered_indices)

    M_reordered = M[reordered_indices, :][:, reordered_indices]
    #print(M_reordered)

    t_len = len(transient_indices)
    a_len = len(target_indices)


    Q = M_reordered[:t_len, :t_len]
    R = M_reordered[:t_len, t_len:]
    zero_block = lil_matrix((a_len, t_len))
    identity_block = identity(a_len)

    top = hstack([Q, R])
    bottom = hstack([zero_block, identity_block])
    canonical = vstack([top, bottom])

    return Q.tocsr()


#Q = create_Q_matrix(0.25, 0.25, 0.25, 0.25)
#print(Q.shape)



'''
mu_0 = np.ones(L**2 * 4 - 4)
for i in range(L**2 * 4 - 4):
  if i in target_indices:
    continue
  else:
    mu_0[i] = 1


mu_0 = mu_0 / np.sum(mu_0)
'''


def find_time(p):

  p2 = (1 - p) / 3
  Q = create_Q_matrix(p, p2, p2, p2)


  I = identity(L**2 * 4 - 4).tocsr()
  N = I.copy()
  Q_power = Q
  for t in range(1, T_max):
     N += Q_power
     Q_power = Q_power @ Q


  c = np.ones((L**2 * 4 - 4, 1))
  mfpt = N @ c
  meantime = np.sum(mfpt) / (L**2 * 4)


  #
  #return mfpt
  return meantime



print("sum of mu:", np.sum(mu_0))


def find_mass(p):
  p2 = (1 - p) / 3
  Q = create_Q_matrix(p, p2, p2, p2)
  M = create_M_matrix(p, p2, p2, p2)
  mu_t = np.zeros((T_max+1, L**2 * 4))
  mu_t[0] = mu_0
  mu_sums = []
  mu_sums.append(np.sum(mu_0))
  for t in range(T_max - 1):
    mu_ttt = M @ mu_t[t]
    mu_t[t+1] = mu_ttt

    mu_sum = np.sum(mu_ttt)

    mu_sums.append(mu_sum)

  return mu_sums


mus = find_mass((0.47967390338107563))

plt.plot(range(T_max), mus, label = 'static p1')





total_prob = [np.sum(mu) for mu in mu_traj]
plt.plot(t, total_prob)
plt.title("Total Probability Mass Over Time")
plt.xlabel("Time")
plt.ylabel("Sum of mu(t) over all states")

plt.show()