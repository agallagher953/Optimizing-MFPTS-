# -*- coding: utf-8 -*-
"""1d-prw-mfpt-optimization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/gist/agallagher953/177d735dc1dfabb961cd0b9f424baf54/1d-prw-mfpt-optimization.ipynb
"""

import numpy as np
import random
import matplotlib.pyplot as plt
from scipy.optimize import minimize_scalar

N = 1000  #Number of walkers
L = 10    #Total space
T = 10000    #time steps
x_0 = 9   #Initial position
dx = 1    # step size
a = .5    # persistance level





Vmatrix = np.zeros((T, N)) # velocity matrix
Xmatrix = np.zeros((T, N)) # position matrix

target_loc = 9    # choose target location here
print(f"target location: {target_loc}")
'''
def vinitial():   # chooses initial velocity
  r = random.random()
  if r > .5:
    return 1
  else:
    return -1
'''

# equal number of v_initial directions
def vinitial(i):
  if (i) % 2 == 0:
    return 1
  else:
    return -1

'''
def vinitial(i):
  up = 1
  down = -1
  return down # choose initial velocity
'''



def v_t(prev_v, p1): # determine new v
  r = random.random()
  if r < p1:
    v = prev_v
  else:
    v = -prev_v

  return v




def x_pos(pos_i, p1):
    fpt = np.zeros(N) # first passage times
    for n in range(N):
        x = int(pos_i)
        Xmatrix[0, n] = x # set initial position

        v = vinitial(n)
        Vmatrix[0, n] = v #initialize initial velocity

        for t in range(1, T):



            v = np.array(v_t(Vmatrix[t-1,n], p1)) #assign velocities
            Vmatrix[t, n] = v

            step = v * dx

            x = x + step # position update


            if x >= L:  # periodic boundary conditions
                x -= L
            elif x < 0:
                x += L

            Xmatrix[t, n] = x # assign new positions

            if x == target_loc: # check to see if walker has hit target
                fpt[n] = t # fill array with first passage times
                break
    return fpt



fig, (plot1, plot2) = plt.subplots(1, 2, figsize=(15, 4)) # subplots

# calculate mfpt to (target_loc) for N walkers from a single point (x_0)
fpt = x_pos(x_0, a)
fpt = fpt[fpt > 0]



mfptY = np.sum(fpt / N) # mean from all fpts / N
print(f"MFPT:{mfptY} from x_0 = {x_0}")
print(f"{len(fpt)} walkers reached the target out of {N}")

#mfpt = np.mean(fpt) # mean from numpy
#print(f"MFPT:{mfpt} from x_0 = {x_0}")


###### Histogram ######
plot1.hist(fpt, bins = 150, edgecolor = 'black', density = True)
plot1.set_title("MFPT probabilty distribution")
plot1.set_ylabel("first passage time probability distribution")
plot1.set_xlabel("First Passage Time (t)")
#######################


# idea for equilibration problem, doesnt work with target search very well in this code
'''
t = 7
Peq = np.zeros(L)
Peq = Xmatrix[t,:]
plot2.hist(Peq, bins = 150, edgecolor = 'black', density = True)
print(Peq)
'''










'''
############## GLOBAL MFPT #################
# calculate MFPT for whatever 'a' value is set above
FPTS = []
for i in range(L):
  if i == target_loc:  # skip target
    continue

  fpt = x_pos(i, a)
  fpt = fpt[fpt > 0]
  FPTS.extend(fpt)



MFPTSY = np.mean(FPTS)
print(f"MFPT over all positions:{MFPTSY} with {len(FPTS)} walkers that made it out of {(L - 1) * N}")
'''

x_start = 0


# calculating mfpt for diff positions
def mfpt(p1):
  all_MFPTS = []
  for x_start in range(L):
    fpt = x_pos(x_start, p1)
    fpt = fpt[fpt > 0]
    MFPT = np.mean(fpt)
    #all_MFPTS.append((x_start, MFPT))
    all_MFPTS.append(MFPT)
  mfpt = np.mean(all_MFPTS)
  return mfpt


result = minimize_scalar(mfpt, bounds=(.5, 1), method='bounded')
#print(result)
print("minimum p1:",result.x)
print("MFPT:",result.fun)
'''
all_MFPTS = np.array(all_MFPTS)
plot2.scatter(all_MFPTS[:, 0], all_MFPTS[:, 1])
plot2.set_xlabel("initial position")
plot2.set_ylabel("MFPT")
plot2.set_title("MFPT(x)")
plot2.axvline(target_loc, color = 'r', linestyle = '--')
'''








#fig, (plot3, plot4) = plt.subplots(1, 2, figsize=(15, 4)) # 2nd set of subplots




plt.show()