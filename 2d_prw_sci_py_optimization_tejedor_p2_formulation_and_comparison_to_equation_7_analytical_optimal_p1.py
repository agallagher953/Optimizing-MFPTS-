# -*- coding: utf-8 -*-
"""2D PRW sci-py optimization tejedor p2 formulation and comparison to equation 7 analytical optimal p1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XtZE2jbF1uCYo4jltkKh2s9AymyYeL7S
"""

import numpy as np
import random
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import math as m

from scipy.sparse import lil_matrix
from scipy.sparse import identity
from scipy.sparse.linalg import spsolve
N = 500  #Number of walkers
L = 10   # Length of lattice
T = 2000   #time steps
dx = 1      #step space
p_1 = .25
#p_2 = (1-p_1)/3
#p_3 = p_2
#p_4 = p_2
p_2 = .25
p_3 = .25
p_4 = .25

probs = [p_1, p_2, p_3, p_4]


fig, (plot1, plot2) = plt.subplots(1, 2, figsize=(15, 4)) # subplots
##################### STOCHASTIC ###########################
coordinates = np.arange(L) # creates array from 0 to L
Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows


target_loc = pos_matrix[L - 1,L - 1] # choose target location

'''
Xmatrix = np.zeros((T, N, 2))  # (x, y) position matrix
Vmatrix = np.zeros((T, N, 2))  # (vx, vy) velocity matrix

# transformation matrices
a_matrix = np.array([[1,0],[0,1]]) # forward
b_matrix = np.array([[-1,0],[0,-1]]) # backward
c_matrix = np.array([[0,-1],[1,0]]) # left
d_matrix = np.array([[0,1],[-1,0]]) # right

# random vinitial function
def vinitial(i):   # chooses initial velocity
  r = random.choice([[0,1],[0,-1],[1,0],[-1,0]])
  return r

#possible tejedor vinitial function?
def vinitial(i):
  if (i) % 4 == 0:
    return np.array([1,0])
  elif (i) % 4 == 1:
    return np.array([-1,0])
  elif (i) % 4 == 2:
    return np.array([0,1])
  else:
    return np.array([0,-1])


# version 3 (tejedor)
def v_t(prev_v, p_1, p_2, p_3):
    r = random.random()
    if r < p_1:
      R = a_matrix  # move forward
    elif r < p_1 + p_2:
      R = b_matrix  # move backward
    elif  r < p_1 + p_2 + p_3:
      R = c_matrix  # turn left
    else:
      R = d_matrix  # turn right

    v = R @ np.array(prev_v)
    return v


# position update function
def x_pos(pos_i, p1, p2, p3):
    fpt = np.zeros(N) # intitialize first passage times array
    for n in range(N):
        x = np.array(pos_i)
        Xmatrix[0, n] = x # set initial position

        v = np.array(vinitial(n))
        Vmatrix[0, n] = v #initialize initial velocity

        for t in range(1, T):

            v = np.array(v_t(Vmatrix[t-1,n], p1, p2, p3)) #assign velocities
            Vmatrix[t, n] = v

            step = v * dx

            x = x + step # position update
            x = x % L # boundary condition

            Xmatrix[t, n] = x # assign new positions

            if np.array_equal(Xmatrix[t,n], target_loc): # check to see if walker has hit target
                fpt[n] = t # fill array with first passage times
                break # stop the random walk

    return fpt


# run trajectories over all starting positions

 # initialize list for all FPTs
def mfpt(p1, p2, p3):
  all_fpt = []
  for i in range(L): #x
    for j in range(L): #y
        start_pos = pos_matrix[i, j]



        fpt = x_pos(start_pos, p1, p2, p3) # calculate FPTs and fill array for each position

        fpt = fpt[fpt > 0] # only fill list with real FPTs
        all_fpt.extend(fpt) # add all the FPTs to all_fpt list
  if len(all_fpt) == 0:
        return T

  mfpt = np.mean(all_fpt)

  return mfpt


m = mfpt(p_1, p_2, p_3)
print("Stochastic Global MFPT:", m)

#result = minimize_scalar(mfpt, bounds=(0.5, .75), method='bounded')

#print("optimal p1:", result.x)
#print("minimum MFPT:", result.fun)


'''

################### MATRIX COMPUTATION ######################



def coord_to_index(i,j,k):
  M = L**2
  if k == 0:
    return j + i * L
  elif k == 1:
    return j + i * L + M
  elif k == 2:
    return j + i * L + 2 * M
  else:
    return j + i * L + 3 * M


def k_prime(k, l):
  if l == 0:
    return k
  elif l == 1:
    if k == 0:
      return 1
    elif k == 1:
      return 0
    elif k == 2:
      return 3
    else:
      return 2

  elif l == 2:
    if k ==0:
      return 2
    elif k == 1:
      return 3
    elif k == 2:
      return 1
    else:
      return 0

  elif l == 3:
    if k == 0:
      return 3
    elif k == 1:
      return 2
    elif k == 2:
      return 0
    else:
      return 1


def create_M_matrix(p1, p2, p3, p4):
    M_matrix = lil_matrix((L**2 * 4, L**2 * 4))
    probs = [p1, p2, p3, p4]

    direction_vectors = {
        0: (0, 1),   #dj = +1
        1: (0, -1),  #dj = -1
        2: (1, 0),   #di = +1
        3: (-1, 0)   #di = -1
    }

    for i in range(L):
        for j in range(L):
            for k in range(4):
                index = coord_to_index(i, j, k)   # find initial index

                #if [i, j] == target_loc:
                if [i, j] == list(target_loc):  # zero out target loc rows
                   continue


                for l in range(4):
                  prob = probs[l]       #choose probability
                  new_k = k_prime(k,l)    #find new velocities

                  di, dj = direction_vectors[new_k]     # find new direction change
                  ni, nj = (i + di) % L, (j + dj) % L   # update position


                  next_index = coord_to_index(ni, nj, new_k)    #convert back to index

                  M_matrix[index, next_index] = prob     #fill matrix with prob to go from (i, j, k) to (i', j', k')


    return M_matrix.tocsr()




def theory_MFPT(p1, p2, p3, p4):
  A_vector = np.ones((L**2 * 4,1))
  for l in range(4):
    A_vector[target_loc[0] + L * target_loc[1] + l * L**2] = 0



  I = identity(L**2 * 4).tocsr()
  M_matrix = create_M_matrix(p1, p2, p3, p4)


  T_matrix = spsolve(I - M_matrix, A_vector).reshape(-1, 1)

  for l in range(4):
   T_matrix[target_loc[0] + L * target_loc[1] + l * L**2] = 0   #Kac Theorum

  return T_matrix

############################################# Analytical

def create_q_matrix(L):
    q_matrix = np.zeros((L, L), dtype=object)
    for n in range(L):
        for m in range(L):
            q_matrix[n, m] = np.array([(2 * np.pi * n) / L, (2 * np.pi * m) / L])
    return q_matrix


def create_A_value(e, L):

  A =  -(e * (L**2 - 1))/(1 - e)
  return A


def create_B_value(e):
  B = (1 + e**2)/(1 - e**2)
  return B


def create_h_matrix(e, q):
    h_matrix = np.zeros((L, L))

    for n in range( L):
        for m in range( L):
            qn = q[n, m][0]
            qm = q[n, m][1]

            if n == 0 and m == 0:
                h_matrix[0, 0] = 0
                continue


            a = (((e - 1)**2) / 2) * (np.cos(qn) / (1 + e**2 - 2 * e * np.cos(qn)))
            b = (((e - 1)**2) / 2) * (np.cos(qm) / (1 + e**2 - 2 * e * np.cos(qm)))


            c = a + b

            h_matrix[n, m] = 1 / (1 - c)
    #print(h_matrix)


    return h_matrix



def Q_sum(e, L):
    q_matrix = create_q_matrix(L)
    h_matrix = create_h_matrix(e, q_matrix)


    sum = np.sum(h_matrix[0,1:L]) + np.sum(h_matrix[1:L, 0]) + np.sum(h_matrix[1:L, 1:L])

    return sum



def TIME(e, L):
    A = create_A_value(e, L)
    B = create_B_value(e)
    q_sum = Q_sum(e, L)
    return  A + B * q_sum


################################## MATRIX optimization

def cost_function(p):   # cost function where p2 = p3 = p4

    p1 = p[0]
    p2 = (1 - p[0]) / 3
    p3 = (1 - p[0]) / 3
    p4 = (1 - p[0]) / 3

    MFPT = np.mean(theory_MFPT(p1, p2, p3, p4))


    return MFPT / (L ** 2)


p1_min = 0
p1_max = .99
p2_min = 0
p2_max = .99
p3_min = 0
p3_max = .99
p4_min = 0
p4_max = .99
bounds = [(p1_min, p1_max),(p2_min, p2_max),(p3_min, p3_max),(p4_min, p4_max)]

#set initial values for control parameters
p_1 = .25
p_2 = .25
p_3 = .25
p_4 = .25

p0 = [p_1, p_2, p_3, p_4]   #guess


constraints = ({
    'type': 'eq',
    'fun': lambda p: np.sum(p) - 1      #probability constraint
})



L_list = []

opt_p1 = []
opt_p2 = []
opt_p3 = []
opt_p4 = []
mfpt_opt = []


####### MATRIX optimization
def MFPT_opt(p1):
  p2 = (1-p1)/3
  p3 = p2
  p4 = p2

  T_fpt = theory_MFPT(p1, p2, p3, p4)
  MFPT_opt = np.mean(T_fpt)

  return MFPT_opt
'''
L = 10
while L <= 20:

  coordinates = np.arange(L) # creates array from 0 to L
  Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
  pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows
  target_loc = pos_matrix[L - 1,L - 1] # choose target location



  A_vector = np.ones((L**2 * 4,1))
  for l in range(4):
    A_vector[target_loc[0] + L * target_loc[1] + l * L**2] = 0

  I = np.identity(L**2 * 4)





  result = minimize(cost_function, p0,  method='SLSQP',  bounds=bounds,  constraints=constraints,  options={ 'maxiter': 500, 'ftol': 1e-6})



  opt_p1.append(result.x[0])
  opt_p2.append(result.x[1])
  opt_p3.append(result.x[2])
  opt_p4.append(result.x[3])
  mfpt_opt.append(result.fun * L**2)

  L_list.append(L)


  #print("optimized scalar value p1:", result.x[0])
  #print("optimized scalar value p2:", result.x[1])
  #print("optimized scalar value p3:", result.x[2])
  #print("optimized scalar value p4:", result.x[3])
  #print("cost:", result.fun)

  #print(L)
  print(f"For a latiice of size: L = {L}")
  print("optimized scalar value p1:", result.x[0])
  #print("optimized scalar value p2:", result.x[1])
  #print("optimized scalar value p3:", result.x[2])
  #print("optimized scalar value p4:", result.x[3])
  print("cost:", result.fun * (L**2))

  L += 1
'''

print("ANALYTICAL OPTIMIZATION")
######################################################################## ANALYTICAL OPTIMIZATION


L = 100
L_list =[]
indexlist = []
optp1_list = []
min_time_list = []
while L <= 100:
  e = 0
  L_list.append(L)

  e_list = []
  p1_list = []
  time_list = []

  while e <= .97:

    p1 = (1 + 3 * e)/4
    p2 = (1 - p1)/3

    #p2 = (1 - e)/4
    #p1 = p2 + e


    probs = [p1, p2, p2, p2]

    #print(np.sum(probs))

    p1_list.append(p1)


    time = TIME(e, L)
    time_list.append(time)

    e_list.append(e)
    e += .01

  indexlist.append(np.argmin(time_list))
  min_time_list.append(min(time_list))


  optp1_list.append(p1_list[indexlist[L-100]])


  print("L =", L)
  print("optimal MFPT:", min(time_list))
  print("optimal p1",p1_list[indexlist[L-100]])
  L += 1




##################################################################### MATRIX Optimization where p2 = 0
def COST_function(p):


    MFPT = np.mean(theory_MFPT(p[0], p[1], p[2], p[3]))


    return MFPT / (L ** 2)




OPT_p1 = []
OPT_p2 = []
OPT_p3 = []
OPT_p4 = []
MFPT_opt = []
'''
L = 2
while L <= 50:

  coordinates = np.arange(L) # creates array from 0 to L
  Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
  pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows
  target_loc = pos_matrix[L - 1,L - 1] # choose target location



  A_vector = np.ones((L**2 * 4,1))
  for l in range(4):
    A_vector[target_loc[0] + L * target_loc[1] + l * L**2] = 0

  I = np.identity(L**2 * 4)





  result = minimize(COST_function, p0,  method='SLSQP',  bounds=bounds,  constraints=constraints,  options={ 'maxiter': 500, 'ftol': 1e-6})



  OPT_p1.append(result.x[0])
  OPT_p2.append(result.x[1])
  OPT_p3.append(result.x[2])
  OPT_p4.append(result.x[3])
  MFPT_opt.append(result.fun * L**2)






  #print("optimized scalar value p1:", result.x[0])
  #print("optimized scalar value p2:", result.x[1])
  #print("optimized scalar value p3:", result.x[2])
  #print("optimized scalar value p4:", result.x[3])
  #print("cost:", result.fun)

  #print(L)
  print(f"For a latiice of size: L = {L}")
  print("optimized scalar value p1:", result.x[0])
  #print("optimized scalar value p2:", result.x[1])
  #print("optimized scalar value p3:", result.x[2])
  #print("optimized scalar value p4:", result.x[3])
  print("cost:", result.fun * (L**2))

  L += 1

'''




###################################################################### Plotting
'''
#plot1.scatter(L_list, MFPT_opt, label = "MFPT")
plot1.scatter(L_list, opt_p1,color = (1,0,0), label = "Matrix p1, p2 = (1 - p1)/3")
#plot1.scatter(L_list, opt_p2, label = "Matrix p2")
#plot1.scatter(L_list, opt_p3, label = "Matrix p3")
#plot1.scatter(L_list, opt_p4, label = "Matrix p4")
plot1.set_title("Optimal Probabilities for L X L Lattice")
plot1.set_xlabel("L")
plot1.set_ylabel("Probabilities")


plot1.scatter(L_list, optp1_list,color = (0,1,0), label = "Analytical p1, p2 = (1 - p1)/3" )



#plot1.scatter(L_list, OPT_p1,color = (0,0,1), label = "Matrix p1, p2 = 0" )



plot1.legend()
'''
'''
############## Matrix MFPT plot
plot2.scatter(L_list, mfpt_opt,color = (1,0,0), label = "Matrix MFPT, p2 = (1 - p1)/3")
plot2.set_title("Optimal MFPT for L X L Lattice")
plot2.set_xlabel("L")
plot2.set_ylabel("MFPT")
'''
############## Analytical MFPT plot
plot2.scatter(L_list, min_time_list,color = (0,1,0), label = "MFPT, p2 = (1 - p1)/3")

plot2.set_title("Optimal MFPT for L X L Lattice")
plot2.set_xlabel("L")
plot2.set_ylabel("MFPT")

'''

plot2.scatter(L_list, MFPT_opt,color = (0,0,1), label = "MFPT, p2 = 0" )
'''
plot2.legend()


plt.show()