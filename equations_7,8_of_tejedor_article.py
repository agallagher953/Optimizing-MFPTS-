# -*- coding: utf-8 -*-
"""Equations 7,8 of Tejedor Article.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mtvcVpRXbxq56WvwfvfpT_po1UU4DVbC
"""

import numpy as np
import random
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import math as m

from scipy.sparse import lil_matrix
from scipy.sparse import identity
from scipy.sparse.linalg import spsolve

L = 10
e = .5

fig, (plot1, plot2) = plt.subplots(1, 2, figsize=(15, 4)) # subplots


############################################### EQUATION 7 FORMULATION
#basis_vectors = [[1,0], [0,1]]

def create_q_matrix(L):
    q_matrix = np.zeros((L, L), dtype=object)
    for n in range(L):
        for m in range(L):
            q_matrix[n, m] = np.array([(2 * np.pi * n) / L, (2 * np.pi * m) / L])
    return q_matrix


def create_A_value(e, L):

  A =  -(e * (L**2 - 1))/(1 - e)
  return A


def create_B_value(e):
  B = (1 + e**2)/(1 - e**2)
  return B


def create_h_matrix(e, q):
    h_matrix = np.zeros((L, L))

    for n in range( L):
        for m in range( L):
            qn = q[n, m][0]
            qm = q[n, m][1]


            a = (((e - 1)**2) / 2) * (np.cos(qn) / (1 + e**2 - 2 * e * np.cos(qn)))
            b = (((e - 1)**2) / 2) * (np.cos(qm) / (1 + e**2 - 2 * e * np.cos(qm)))


            c = a + b

            h_matrix[n, m] = 1 / (1 - c)
    #print(h_matrix)


    return h_matrix



def Q_sum(e, L):
    q_matrix = create_q_matrix(L)
    h_matrix = create_h_matrix(e, q_matrix)


    sum = np.sum(h_matrix[0,1:L]) + np.sum(h_matrix[1:L, 0]) + np.sum(h_matrix[1:L, 1:L])

    return sum



def TIME(e, L):
    A = create_A_value(e, L)
    B = create_B_value(e)
    q_sum = Q_sum(e, L)
    return  A + B * q_sum




time = TIME(0, 10)
print(time)







q = create_q_matrix(L)
h = create_h_matrix(e, q)
A = create_A_value(e, L)
B = create_B_value(e)

#print(q)
#print(h[0,0])
#print(h)
#print(A)
#print(B)


############# e(L) relationship

L = 2
e = 0




L_list =[]
indexlist = []
optp1_list = []
min_time_list = []
while L <= 50:
  e = 0
  L_list.append(L)

  e_list = []
  p1_list = []
  time_list = []

  while e <= .86:

    p1 = (1 + 3 * e)/4
    p2 = (1 - p1)/3

    #p2 = (1 - e)/4
    #p1 = p2 + e


    probs = [p1, p2, p2, p2]

    #print(np.sum(probs))

    p1_list.append(p1)


    time = TIME(e, L)
    time_list.append(time)

    e_list.append(e)
    e += .001

  indexlist.append(np.argmin(time_list))
  min_time_list.append(min(time_list))


  optp1_list.append(p1_list[indexlist[L-2]])

  #print("optimal e",e_list[indexlist[L-2]])


  print("L =", L)
  print("optimal MFPT:", min(time_list))
  print("optimal p1",p1_list[indexlist[L-2]])
  L += 1


plt.scatter(L_list, optp1_list)
plt.xlabel("L")
plt.ylabel("MFPT")





############# optimal e for given lattice

'''
L = 10

e_list = []
time_list = []
while e <= .86:

    time = TIME(e, L)
    time_list.append(time)

    e_list.append(e)
    e += .01






plt.scatter(e_list, time_list)
plt.xlabel("e")
plt.ylabel("MFPT")

'''




plt.show()