# -*- coding: utf-8 -*-
"""old state-dependent MDP, has good map.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_keOgW9SYGDvG76X98qUsCrI6G20o4O2
"""

####################### MDP ON ALL STATES
import numpy as np
import random
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import math as m

from scipy.sparse import csr_matrix
from scipy.sparse import lil_matrix
from scipy.sparse import identity
from scipy.sparse.linalg import spsolve


fig, (plot1, plot2) = plt.subplots(1, 2, figsize=(15, 4)) # subplots


L = 5
T_max = 50
coordinates = np.arange(L) # creates array from 0 to L
Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows


target_loc = pos_matrix[L // 2,L // 2]

# Create transition matrix functions

def coord_to_index(i,j,k):
  M = L**2
  if k == 0:
    return j + i * L
  elif k == 1:
    return j + i * L + M
  elif k == 2:
    return j + i * L + 2 * M
  else:
    return j + i * L + 3 * M


def k_prime(k, l):
  if l == 0:
    return k
  elif l == 1:
    if k == 0:
      return 1
    elif k == 1:
      return 0
    elif k == 2:
      return 3
    else:
      return 2

  elif l == 2:
    if k ==0:
      return 2
    elif k == 1:
      return 3
    elif k == 2:
      return 1
    else:
      return 0

  elif l == 3:
    if k == 0:
      return 3
    elif k == 1:
      return 2
    elif k == 2:
      return 0
    else:
      return 1

def create_M_matrix(p1, p2, p3, p4):
    M_matrix = lil_matrix((L**2 * 4, L**2 * 4))
    probs = [p1, p2, p3, p4]
    direction_vectors = {
        0: (0, 1),   #dj = +1
        1: (0, -1),  #dj = -1
        2: (1, 0),   #di = +1
        3: (-1, 0)   #di = -1
    }
    for i in range(L):
        for j in range(L):
            for k in range(4):
                index = coord_to_index(i, j, k)   # find initial index

                #if [i, j] == target_loc:
                if [i, j] == list(target_loc):  # zero out target loc rows
                   continue
                for l in range(4):
                  prob = probs[l]       #choose probability
                  new_k = k_prime(k,l)    #find new velocities
                  di, dj = direction_vectors[new_k]     # find new direction change
                  ni, nj = (i + di) % L, (j + dj) % L   # update position
                  next_index = coord_to_index(ni, nj, new_k)    #convert back to index
                  M_matrix[index, next_index] = prob     #fill matrix with prob to go from (i, j, k) to (i', j', k')
    return M_matrix.tocsr()

### MDP

target_indices = []
for k in range(4):
  target_indices.append(coord_to_index(target_loc[0], target_loc[1], k))

V = np.zeros((T_max + 1, L**2 * 4))   # value function initialization
V[:, target_indices] = 0

mu_0 = np.ones(L**2 * 4)
mu_0[target_indices] = 0
mu_0 = mu_0 / np.sum(mu_0) # inital state
#print(mu_0)


# Backward Recursion
best_p1 = np.zeros((T_max,L**2 * 4))
p1_values = np.linspace(0, 1, 500) # CHOOSE HERE WHICH P1 VALUES TO USE IN P1(T)     # (lower bound, upper bound, number of divisions)


M_matrices = {}  # Store M matrices for each p1 value
for p1 in p1_values:
    p234 = (1 - p1) / 3
    M_matrices[p1] = create_M_matrix(p1, p234, p234, p234)


one_vector = np.ones(L**2 * 4)
one_vector[target_indices] = 0    # skip target state???


##################### Value iteration of bellman equation
for t in reversed(range(T_max)):

  for s in range(L**2 * 4):
    best_cost = 1e9
    if s in target_indices:
      continue

    for p1 in p1_values:
      M = M_matrices[p1]


      #Q[s] = one_vector + (M @ V[t + 1].reshape(-1, 1)).flatten()      # Bellman equation iteration
      Q = one_vector + M @ V[t + 1]


      E_T = Q[s]



      if E_T < best_cost: # Minimization, find the minimum expected MFPT
          best_cost = E_T   # set best cost to expected cost to compare different expected MFPT(p1)
          V[t,s] = Q[s]  # Update V[t] with the Q that gives the minimum cost
          best_p1[t,s] = p1 # sets best_p1 with the p1 which gives the minimum expected cost
          #print(best_cost)


def find_fpt(state_index):
    return mu_0[state_index] * V[0, state_index]








def find_prob_mass():
    mu_t = np.zeros((T_max, L**2 * 4))    # all states all time
    mu_t[0] = mu_0
    mu_t_sum = [np.sum(mu_0)]
    for t in range(1, T_max):

        row_indices = []
        col_indices = []
        data = []

        for i in range(L):
            for j in range(L):
                for k in range(4):
                    s = coord_to_index(i, j, k)   #s = all states
                    if s in target_indices:
                        continue

                    p1 = best_p1[t, s]      # call best p1(t,s)
                    p234 = (1 - p1) / 3
                    probs = [p1, p234, p234, p234]
                    direction_vectors = {
                        0: (0, 1), 1: (0, -1), 2: (1, 0), 3: (-1, 0)
                    }

                    for l in range(4):
                        new_k = k_prime(k, l)
                        di, dj = direction_vectors[new_k]
                        ni, nj = (i + di) % L, (j + dj) % L
                        next_s = coord_to_index(ni, nj, new_k)

                        row_indices.append(s)
                        col_indices.append(next_s)
                        data.append(probs[l])

        M_t = csr_matrix((data, (row_indices, col_indices)), shape=(L**2 * 4, L**2 * 4))

        #print(M_t)
        mu_t[t] = M_t @ mu_t[t-1]
        mu_t[t, target_indices] = 0

        mu_t_sum.append(np.sum(mu_t[t]))

    return mu_t_sum

#print(find_prob_mass())








probmass = find_prob_mass()
#print(probmass)



plot2.plot(probmass, label = 'Probability In Transient States')
plot2.set_title(f"Probability In Transient States Over Time")
plot2.set_xlabel("Time")
plot2.set_ylabel("Probability")
plt.legend()







MFPT = 0

for i in range(L):
    for j in range(L):
        for k in range(4):
            s = coord_to_index(i, j, k)
            MFPT += mu_0[s] * V[0, s]


print("MFPT:", MFPT)


avg_p1t = np.zeros(T_max)
for t in range(T_max):
    avg_p1t[t] = np.mean(best_p1[t])    # average over p1(t,s) for p1(t)
    #avg_p1t[t] = (best_p1[t,3])



plot1.plot(avg_p1t)       # plotting p1(t) avg over all states
plot1.set_xlabel("Time step")
plot1.set_ylabel("Optimal p1")
plot1.set_title("Optimal Control p1(t) Over Time")


def find_best_prob(i, j, k):    # find best p1 value at tiime = 0 / best move at time = 0
    directions = {0: (0, 1), 1: (0, -1), 2: (1, 0), 3: (-1, 0)}
    move = best_p1[0, coord_to_index(i, j, k)]
    if move > 0.5:
        return directions[k]
    else:
        return directions[k_prime(k, 1)]






Is = np.zeros((L, L))
Js = np.zeros((L, L))

p1_s_map = np.zeros((L, L))

for i in range(L):
    for j in range(L):
        best_fpt = 1e9
        for k in range(4):
            idx = coord_to_index(i, j, k)
            fpt = find_fpt(idx)
            if fpt < best_fpt:
                best_fpt = fpt
                p1_s_map[i, j] = fpt    # heat map

                dx, dy = find_best_prob(i, j, k)    # find best initial direction
                Is[i, j] = dx
                Js[i, j] = dy

        if (i, j) == (target_loc[0], target_loc[1]):
            Is[i, j] = 0
            Js[i, j] = 0







plt.figure(figsize=(8 ,8))
plt.imshow(p1_s_map.T, origin='lower', cmap='viridis', extent=[0, L, 0, L])
plt.colorbar(label='Minimum FPT')
plt.quiver(np.arange(L) + .5, np.arange(L) + .5, Is.T, Js.T, color='black')
plt.scatter(target_loc[0] + .5,target_loc[1] + .5, c='red',marker='X', label='Target')
plt.title("Optimal Paths to Target")
plt.legend()



p1_s = np.zeros(T_max)
p1_s = best_p1[0]
#print(p1_s)



plt.show()