# -*- coding: utf-8 -*-
"""optimization vector using scipy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1649cceU1S-3fnK0MV7nsasFVoSTirGum
"""

import numpy as np
import math as m
import random
import matplotlib.pyplot as plt
from scipy.optimize import minimize

L = 10       # choose number of elements in array

l_step = 5

initial_state = np.ones(L)

initial_state[0:L] = random.random()

print("initial state:",initial_state)



p1 = .2
p2 = .7

target_state = np.ones(L)    # initialize target state array
target_state[0:l_step] = p1
target_state[l_step:L] = p2
print("target state:", target_state)



def step_function(u, x):
    x_1 = np.zeros(L)
    x_1[0:l_step] = x[0:l_step]
    x_2 = np.zeros(L)
    x_2[l_step:L] = x[l_step:L]

    return np.multiply(u[0], x_1) + np.multiply(u[1], x_2)






def cost_function(u, x, f_eq):
    f_x = step_function(u, x)
    y = f_x - f_eq
    return np.inner(y, y)



u_min0=0
u_max0=3
u_min1=0
u_max1=1
bounds = [(u_min0, u_max0),(u_min1, u_max1)]

#set initial values for control parameters
u_0=1.0
u_1=1.0

u=np.zeros(2,dtype=float)
u[0]=u_0
u[1]=u_1


opt_sol = minimize(cost_function, u, args=(initial_state,target_state), method='L-BFGS-B', bounds=bounds)

u0_sol=opt_sol.x[0]  #optimal value for 1st control parameter ("a")
u1_sol=opt_sol.x[1]  #optimal value for 2nd control parameter ("b")



print("optimized scalar value a:", u0_sol)
print("optimized scalar value b:", u1_sol)
print("cost:", opt_sol.fun)






plt.show()