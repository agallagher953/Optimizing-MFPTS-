# -*- coding: utf-8 -*-
"""plotting 2D Tejedor MFPT(p1) approximation (Approximation, stochastic, computational and analytical results).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10GaVj2SX9CRnmCHzT2QnQ5U0azFSDDSD
"""

import numpy as np
import random
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import math as m

from scipy.sparse import lil_matrix
from scipy.sparse import identity
from scipy.sparse.linalg import spsolve

N = 100  #Number of walkers
L = 10   # Length of lattice
T = 10000   #time steps
dx = 1      #step space
a = .5      # persistence level
p_1 = 0.6756479531224381    # prob to go forwards
p_2 = (1 - p_1)/3    # prob to go backwards
p_3 = p_2    # prob to turn left
p_4 = p_2    # prob to turn right
e = 0

coordinates = np.arange(L) # creates array from 0 to L
Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows


target_loc = pos_matrix[2,2] # choose target location



fig, (plot1, plot2) = plt.subplots(1, 2, figsize=(15, 4)) # subplots
fig, (plot3, plot4) = plt.subplots(1, 2, figsize=(15, 4)) # 2nd set of subplots




'''
####################################################################################### APPROXIMATION
e_vals = []
while e <= .88:
  e_vals.append(e)
  e += .01


lp_vals = []
for i in range(len(e_vals)):
  lp = (4 / 3) * (1 / (1 - e_vals[i]))
  lp = lp / L
  lp_vals.append(lp)




A_vals = []
for i in range(len(e_vals)):
  A_vals.append((2 * (L - 1))/(1 - e_vals[i]))
  #A_vals.append((3/2) * (L - 1) * lp_vals[i])


B_value = ((L - 1)**2) / 2


C_vals = []
for i in range(len(e_vals)):
  C = (1 - e_vals[i]) * (((L - 1) * (L + 3) * (L - 2))/12)
  #C = (4/3) * (1 / lp_vals[i]) * (((L - 1) * (L + 3) * (L - 2))/12)
  C_vals.append(C)




MFPT_approx = []
for i in range(len(e_vals)):
  approx_vals = A_vals[i] + B_value + C_vals[i]
  MFPT_approx.append(approx_vals)




MFPT_approx_norm = []


p1_LIST = []

for i in range(len(e_vals)):
    norm = MFPT_approx[i] / MFPT_approx[0]
    MFPT_approx_norm.append(norm)
    p_2 = (1 - e_vals[i]) / 4
    p1_LIST.append(p_2 + e_vals[i])




#plot1.scatter(lp_vals, MFPT_approx_norm, color='green', label='Approximation')
plot1.scatter(p1_LIST, MFPT_approx, color=(0,0,1), label='Approximation')
plot1.set_title("Approximation Equation")
plot1.set_xlabel("lp / L")
plot1.set_ylabel("MFPT / MFPT_0")
'''


##################################################################################### STOCHASTIC SIMULATION




# transformation matrices
a_matrix = np.array([[1,0],[0,1]]) # forward
b_matrix = np.array([[-1,0],[0,-1]]) # backward
c_matrix = np.array([[0,-1],[1,0]]) # left
d_matrix = np.array([[0,1],[-1,0]]) # right

# random vinitial function

def vinitial(i):   # chooses initial velocity
  r = random.choice([[0,1],[0,-1],[1,0],[-1,0]])
  return r
'''
#possible tejedor vinitial function?
def vinitial(i):
  if (i) % 4 == 0:
    return np.array([1,0])
  elif (i) % 4 == 1:
    return np.array([-1,0])
  elif (i) % 4 == 2:
    return np.array([0,1])
  else:
    return np.array([0,-1])
'''





# version 3 (tejedor)

def v_t(prev_v, p1, p2):
    r = random.random()

    if r < p1:
      R = a_matrix  # move forward
    elif r < p1 + p2:
      R = b_matrix  # move backward
    elif  r < p1 + p2 * 2:
      R = c_matrix  # turn left
    else:
      R = d_matrix  # turn right

    v = R @ np.array(prev_v)
    return v


# position update function
def x_pos(pos_i, p1, p2):
    Xmatrix = np.zeros((T, N, 2))  # (x, y) position matrix
    Vmatrix = np.zeros((T, N, 2))  # (vx, vy) velocity matrix


    fpt = np.zeros(N) # intitialize first passage times array
    for n in range(N):
        x = np.array(pos_i)
        Xmatrix[0, n] = x # set initial position



        v = np.array(vinitial(n))
        Vmatrix[0, n] = v #initialize initial velocity

        for t in range(1, T):



            v = np.array(v_t(Vmatrix[t-1,n], p1, p2)) #assign velocities
            Vmatrix[t, n] = v

            step = v * dx

            x = x + step # position update
            x = x % L # boundary condition

            Xmatrix[t, n] = x # assign new positions

            if np.array_equal(Xmatrix[t,n], target_loc): # check to see if walker has hit target
                fpt[n] = t # fill array with first passage times
                break # stop the random walk
            if t == (T - 1):
              fpt[n] = T - 1
              break


    return fpt


# run trajectories over all starting positions

e = 0

all_mfpt = []

while e <= .87:
  p_2 = (1 - e) / 4
  p_1 = p_2 + e

  lp = (4/(4-1)) / (1 - e)
  all_fpt = [] # initialize list for all FPTs
  for i in range(L): #x
    for j in range(L): #y
        start_pos = pos_matrix[i, j]
        if np.array_equal(start_pos, target_loc):
          all_fpt.append(0)
          continue



        fpt = x_pos(start_pos, p_1, p_2) # calculate FPTs and fill array for each position

        fpt = fpt[fpt > 0] # only fill list with FPTs that reached the target
        all_fpt.extend(fpt) # add all the FPTs to all_fpt list

  MFPT = np.mean(all_fpt) #calculate MFPT over all positions and walkers

  all_mfpt.append(MFPT)
  print(p_1)
  print(p_1 + p_2 * 3)


  x = p_1
  #x = lp / L
  #y = MFPT / all_mfpt[0]
  y = MFPT
  plot1.scatter(x, y, color='orange', label="Stochastic Simulation"if e == 0 else"")







  e += .01



##################################################### Matrix MFPT Computation


def coord_to_index(i,j,k):
  M = L**2
  if k == 0:
    return j + i * L
  elif k == 1:
    return j + i * L + M
  elif k == 2:
    return j + i * L + 2 * M
  else:
    return j + i * L + 3 * M


def k_prime(k, l):
  if l == 0:
    return k
  elif l == 1:
    if k == 0:
      return 1
    elif k == 1:
      return 0
    elif k == 2:
      return 3
    else:
      return 2

  elif l == 2:
    if k ==0:
      return 2
    elif k == 1:
      return 3
    elif k == 2:
      return 1
    else:
      return 0

  elif l == 3:
    if k == 0:
      return 3
    elif k == 1:
      return 2
    elif k == 2:
      return 0
    else:
      return 1


def create_M_matrix(p1, p2, p3, p4):
    M_matrix = lil_matrix((L**2 * 4, L**2 * 4))
    probs = [p1, p2, p3, p4]

    direction_vectors = {
        0: (0, 1),   #dj = +1
        1: (0, -1),  #dj = -1
        2: (1, 0),   #di = +1
        3: (-1, 0)   #di = -1
    }

    for i in range(L):
        for j in range(L):
            for k in range(4):
                index = coord_to_index(i, j, k)   # find initial index

                #if [i, j] == target_loc:
                if [i, j] == list(target_loc):  # zero out target loc rows
                    continue


                for l in range(4):
                  prob = probs[l]       #choose probability
                  new_k = k_prime(k,l)    #find new velocities

                  di, dj = direction_vectors[new_k]     # find new direction change
                  ni, nj = (i + di) % L, (j + dj) % L   # update position


                  next_index = coord_to_index(ni, nj, new_k)    #convert back to index

                  M_matrix[index, next_index] = prob     #fill matrix with prob to go from (i, j, k) to (i', j', k')


    return M_matrix.tocsr()



#print(M_matrix)







def theory_MFPT(p1, p2, p3, p4):
  A_vector = np.ones((L**2 * 4,1))
  for l in range(4):
    A_vector[target_loc[0] + L * target_loc[1] + l * L**2] = 0



  I = identity(L**2 * 4).tocsr()
  M_matrix = create_M_matrix(p1, p2, p3, p4)


  T_matrix = spsolve(I - M_matrix, A_vector).reshape(-1, 1)

  for l in range(4):
    T_matrix[target_loc[0] + L * target_loc[1] + l * L**2] = 0   #Kac Theorum

  return T_matrix

###################################################################### ANALYTICAL EQUATION


def create_q_matrix(L):
    q_matrix = np.zeros((L, L), dtype=object)
    for n in range(L):
        for m in range(L):
            q_matrix[n, m] = np.array([(2 * np.pi * n) / L, (2 * np.pi * m) / L])
    return q_matrix


def create_A_value(e, L):

  A =  -(e * (L**2 - 1))/(1 - e)
  return A


def create_B_value(e):
  B = (1 + e**2)/(1 - e**2)
  return B


def create_h_matrix(e, q):
    h_matrix = np.zeros((L, L))

    for n in range( L):
        for m in range( L):
            qn = q[n, m][0]
            qm = q[n, m][1]

            if n == 0 and m == 0:
                h_matrix[0, 0] = 0
                continue


            a = (((e - 1)**2) / 2) * (np.cos(qn) / (1 + e**2 - 2 * e * np.cos(qn)))
            b = (((e - 1)**2) / 2) * (np.cos(qm) / (1 + e**2 - 2 * e * np.cos(qm)))


            c = a + b

            h_matrix[n, m] = 1 / (1 - c)
    #print(h_matrix)


    return h_matrix



def Q_sum(e, L):
    q_matrix = create_q_matrix(L)
    h_matrix = create_h_matrix(e, q_matrix)


    sum = np.sum(h_matrix[0,1:L]) + np.sum(h_matrix[1:L, 0]) + np.sum(h_matrix[1:L, 1:L])

    return sum



def TIME(e, L):
    A = create_A_value(e, L)
    B = create_B_value(e)
    q_sum = Q_sum(e, L)
    return  A + B * q_sum















###################################################################### GRAPHS






'''
all_fpt = [] # initialize list for all FPTs
for i in range(L): #x
    for j in range(L): #y
        start_pos = pos_matrix[i, j]
        if np.array_equal(start_pos, target_loc):
          all_fpt.append(0)
          continue



        fpt = x_pos(start_pos, p_1, p_2) # calculate FPTs and fill array for each position

        fpt = fpt[fpt > 0] # only fill list with FPTs that reached the target
        all_fpt.extend(fpt) # add all the FPTs to all_fpt list

MFPT = np.mean(all_fpt) #calculate MFPT over all positions and walkers


print("MFPT:", MFPT)
'''





L = 10
lp_norms = []
M_all_mfpts = []
norm_theory_mfpt = []
P1list = []

analytical_times = []
e = 0
while e <=.87:
  p_2 = (1 - e) / 4
  p_1 = p_2 + e
  p_3 = p_2
  p_4 = p_2

  P1list.append(p_1)


  lp = ((4/(4-1)) / (1 - e))/L
  lp_norms.append(lp)

  ############################################### Matrix computation
  theory_mfpt = theory_MFPT(p_1, p_2, p_3, p_4)
  #mean_mfpt = np.sum(theory_mfpt) * (1 / (len(theory_mfpt) - 1))
  mean_mfpt = np.mean(theory_mfpt)
  M_all_mfpts.append(mean_mfpt)


  ############################################### Analytical equation computation

  time = TIME(e, L)
  analytical_times.append(time)




  e += .01







plot1.scatter(P1list, M_all_mfpts,color = (1,0,0), label="Matrix MFPT")
plot1.scatter(P1list, analytical_times,color = (0,1,0), label="Analytical MFPT")


#plot2.scatter(lp_norms, M_all_mfpts,color = (1,0,0), label="Matrix MFPT")
#plot2.set_title("Non-Normalized Matrix Computed MFPTS vs. Approximation Equation")
#plot1.set_title("Non-Normalized Matrix Computed and Simulated MFPTS vs. Approximation Equation ")
#plot2.set_xlabel("lp / L")
#plot2.set_ylabel("MFPT / MFPT_0")
#plot2.set_ylabel("MFPT")
plot1.legend()




#print("Approximate MFPT:", MFPT_approx[0])
print("Matrix MFPT:", M_all_mfpts[0])
#print("Stochastic MFPT:", all_mfpt[0])



plt.show()