# -*- coding: utf-8 -*-
"""1D simple RW probability distribution.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1B8Vf-yY5Iz7AG_2LWJsCAekvRGfQyfBl
"""

import numpy as np
import random
import matplotlib.pyplot as plt


N = 1000     #Number of walkers
L = 100    #Total space
T = 100    #time steps
x_0 = 50   #Initial position
dx = 1
p_1 = .4

Xmatrix = np.zeros((T, N))
Vmatrix = np.zeros((T, N))

def v_initial():
  r = random.random()
  if r < 0.5:
    v = 1
  else:
    v = -1
  return v

def v_t(prev_v):
  r = random.random()
  if r < p_1:
    v = 1
  else:
    v = -1
  return v



def x_pos():
    for n in range(N):
        x = x_0
        Xmatrix[0, n] = x
        Vmatrix[0, n] = v_initial()
        for t in range(1, T):

            Vmatrix[t, n] = v_t(Vmatrix[t-1, n])
            step = dx * Vmatrix[t, n]

            x = x + step

            x = x % L  # periodic boundary conditions

            Xmatrix[t, n] = x
    return Xmatrix

Xmatrix = x_pos() # call function/fill matrix

fig, (plot1, plot2) = plt.subplots(1, 2, figsize=(15, 4)) # subplots

#trajectory plots
for n in range(N):
    plot1.plot(Xmatrix[range(T), n])
plot1.set_xlabel("Time (t)")
plot1.set_ylabel("Position (x)")


#Histogram
t = T - 1
pos_t = Xmatrix[t,:]
norm_pos_t = (Xmatrix[t,:])/L

plot2.hist(pos_t, bins=L,  range=(0, L), edgecolor='black', density = True)
plot2.set_title(f"empirical probability distribution at t = {T - 1}")
plot2.set_xlabel("position")
plot2.set_ylabel("probability")






###### theoretical Probability distribution
p_array = np.zeros(L)     # initial distribution delta function
p_array[x_0] = 1

trans_M = np.zeros((L, L))    #transition matrix

for i in range(L):      # create transition matrix
    trans_M[(i + 1) % L, i] = p_1   #right
    trans_M[(i - 1) % L, i] = (1 - p_1)    #left
######## doesnt work with PRW because transition matrix uses p1 as prob to go left or right

time_evol = np.zeros((T, L))      #initilalize time evolution matrix storage
time_evol[0, :] = p_array

for t in range(1, T):
    time_evol[t, :] = trans_M @ time_evol[t-1, :]   #recursive equation


pd = time_evol[T - 1, :]   # prob dist

fig, (plot3, plot4) = plt.subplots(1, 2, figsize=(15, 4)) # 2nd set of subplots


########## only works when p_1 = .5
plot3.hist(pos_t, bins=L,  range=(0, L), edgecolor='black', density = True)  # overlays empirical distribution


plot3.plot( pd)
plot3.set_title(f"theoretical probability distribution at t = {T - 1}")
plot3.set_xlabel("position")
plot3.set_ylabel("probability")






















'''
# mean
mean = np.mean(Xmatrix, axis=1)

plot3.plot(range(T), mean, color='black', linewidth=2)
plot3.set_xlabel("Time (t)")
plot3.set_ylabel("Mean")

# 2nd moment
scnd_moment = np.mean(Xmatrix**2, axis = 1)
plt.figure()
plt.xlabel("Time (t))")
plt.ylabel("2nd moment")
plt.plot(range(T), scnd_moment, color='black', linewidth=2)
#variance

#var = np.var(Xmatrix, axis=1)
var = scnd_moment - mean**2
plot4.plot(range(T), var, color='black', linewidth=2)
plot4.set_xlabel("Time (t)")
plot4.set_ylabel("Variance")

#theoretical variance
Tvar = []

for i in range(1,T):
  T = dx**2 * i
  Tvar.append(T)
  i += 1

plot4.plot(range(T), Tvar, color='red', linewidth=2)
'''


plt.show()