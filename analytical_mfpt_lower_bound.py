# -*- coding: utf-8 -*-
"""analytical MFPT lower bound.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13ZSt6hrBxY-ANi0RyCss7iys_85XZ4H7
"""

############ ANALYTICAL OPTIMAL MFPT LOWER BOUND

import numpy as np
import random
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import math as m

from scipy.sparse import lil_matrix
from scipy.sparse import identity
from scipy.sparse.linalg import spsolve

#fig, (plot1, plot2) = plt.subplots(1, 2, figsize=(15, 4)) # subplots


L = 12
T_max = 300
coordinates = np.arange(L) # creates array from 0 to L
Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows


target_loc = pos_matrix[L//2,L//2]




def coord_to_index(i,j,k):
  M = L**2
  if k == 0:
    return j + i * L
  elif k == 1:
    return j + i * L + M
  elif k == 2:
    return j + i * L + 2 * M
  else:
    return j + i * L + 3 * M







target_indices = []
for k in range(4):
  target_indices.append(coord_to_index(target_loc[0], target_loc[1], k))

def find_time(pos_i):


  dx = abs(target_loc[0] - pos_i[0])
  dy = abs(target_loc[1] - pos_i[1])

  x_distance = min(dx, L - dx)
  y_distance = min(dy, L - dy)

  return x_distance, y_distance




def find_best_move(pos):    # best initial move (for arrows)

  directions = {1: (0, 1), 2: (0, -1), 3: (1, 0), 4: (-1, 0)}

  min_dist = 1e9
  best_move = (0, 0)

  for i in directions.values():
      new_pos = ((pos[0] + i[0]) % L, (pos[1] + i[1]) % L)
      d = np.sum(find_time(new_pos))
      if d < min_dist:
          min_dist = d
          best_move = i

  return best_move




time_map = np.zeros((L, L))
I = np.zeros((L, L))
J = np.zeros((L, L))

# Compute values
for i in range(L):
    for j in range(L):
        pos = (i, j)
        time_map[i, j] = np.sum(find_time(pos))
        dx, dy = find_time(pos)


        dx, dy = find_best_move(pos)
        I[i, j] = dx
        J[i, j] = dy

        if pos == (target_loc[0], target_loc[1]):
            I[i, j] = 0
            J[i, j] = 0



mfpt = np.sum(time_map) / (L**2 - 1)
print("MFPT:", mfpt)

#plt.figure(figsize=(8, 8))
plt.imshow(time_map, origin='lower', extent=[0, L, 0, L])
plt.colorbar(label='Minimum FPT')
plt.quiver(np.arange(L) + .5, np.arange(L) + .5, I.T, J.T, color='black')
plt.scatter(target_loc[0] + .5,target_loc[1] + .5, c='red',marker='X', label='Target')
plt.title("Optimal Paths to Target")
plt.legend()



plt.show()