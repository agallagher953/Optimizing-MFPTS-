# -*- coding: utf-8 -*-
"""static optimal p1 value and MFPT for large lattice sizes. (Tejedor analytical equation) .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Bk1gQ6AnnCl87_yK42maeahTtGtCcEa3
"""

import numpy as np
import random
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import math as m

from scipy.sparse import lil_matrix
from scipy.sparse import identity
from scipy.sparse.linalg import spsolve


############################################# Analytical

def create_q_matrix(L):
    q_matrix = np.zeros((L, L), dtype=object)
    for n in range(L):
        for m in range(L):
            q_matrix[n, m] = np.array([(2 * np.pi * n) / L, (2 * np.pi * m) / L])
    return q_matrix


def create_A_value(e, L):

  A =  -(e * (L**2 - 1))/(1 - e)
  return A


def create_B_value(e):
  B = (1 + e**2)/(1 - e**2)
  return B


def create_h_matrix(e, q):
    h_matrix = np.zeros((L, L))

    for n in range( L):
        for m in range( L):
            qn = q[n, m][0]
            qm = q[n, m][1]

            if n == 0 and m == 0:
                h_matrix[0, 0] = 0
                continue


            a = (((e - 1)**2) / 2) * (np.cos(qn) / (1 + e**2 - 2 * e * np.cos(qn)))
            b = (((e - 1)**2) / 2) * (np.cos(qm) / (1 + e**2 - 2 * e * np.cos(qm)))


            c = a + b

            h_matrix[n, m] = 1 / (1 - c)
    #print(h_matrix)


    return h_matrix



def Q_sum(e, L):
    q_matrix = create_q_matrix(L)
    h_matrix = create_h_matrix(e, q_matrix)


    sum = np.sum(h_matrix[0,1:L]) + np.sum(h_matrix[1:L, 0]) + np.sum(h_matrix[1:L, 1:L])

    return sum



def TIME(e, L):
    A = create_A_value(e, L)
    B = create_B_value(e)
    q_sum = Q_sum(e, L)
    return  A + B * q_sum

print("ANALYTICAL OPTIMIZATION")
######################################################################## ANALYTICAL OPTIMIZATION

Lmax = 500


e_min = .85
e_max = .999

bounds = [(e_min, e_max)]

e = .9


def cost_function(e):
  return TIME(e, Lmax)


'''
L = 500
L_list =[]
p1_list = []
time_list = []

while L <= 500:
  #e = 0.99
  L_list.append(L)


  result = minimize(cost_function, .5 , method='SLSQP', bounds=bounds,  options={ 'maxiter': 2000, 'ftol': 1e-8})




  p1 = (result.x[0] * 3 + 1)/4

  p1_list.append(p1)
  time_list.append(TIME(result.x[0], L))

  print("L =", L)
  print("e =", result.x[0])
  print("p1 = ",p1 )
  print("time =", TIME(result.x[0], L))

  L += 1
'''




L = 2000
e_params = np.linspace(.9925,.999999,100)
e_LIST = []
time_LIST = []

for e in e_params:
  times = TIME(e,L)
  time_LIST.append(times)
  e_LIST.append(e)


minimum_time = min(time_LIST)
minimum_index = time_LIST.index(minimum_time)
minimum_e = e_LIST[minimum_index]

print("L =", L)
print("optimal MFPT:", minimum_time)
print("optimal e:",minimum_e)
print("optimal p1:", (minimum_e*3 + 1)/4)



plt.scatter(e_LIST, time_LIST, label = "mfpt(e)")



















#plt.scatter(e_list, time_list, label = "mfpt(e)")

















'''
#plotting
plot1.scatter(L_list, p1_list)
plot1.set_title("p1(L)")
plot1.set_xlabel("L")
plot1.set_ylabel("p1")

plot2.scatter(L_list, time_list)
plot2.set_title("MFPT(L)")
plot2.set_xlabel("L")
plot2.set_ylabel("Time")
'''

plt.show()