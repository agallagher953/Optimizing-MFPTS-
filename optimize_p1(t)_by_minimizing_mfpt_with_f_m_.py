# -*- coding: utf-8 -*-
"""optimize p1(t) by minimizing MFPT with F.M..ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OqkiwQbe3D5ZlcR5rT0edF_BdRY4CXX5
"""

import numpy as np
import random
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import math as m

from scipy.sparse import lil_matrix
from scipy.sparse import identity
from scipy.sparse.linalg import spsolve
from scipy.sparse import lil_matrix, csr_matrix, vstack, hstack, identity

L = 15
T_max = 1500
coordinates = np.arange(L) # creates array from 0 to L
Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows


target_loc = pos_matrix[L // 2,L // 2]

# Create transition matrix functions

def coord_to_index(i,j,k):
  M = L**2
  if k == 0:
    return j + i * L
  elif k == 1:
    return j + i * L + M
  elif k == 2:
    return j + i * L + 2 * M
  else:
    return j + i * L + 3 * M


def k_prime(k, l):
  if l == 0:
    return k
  elif l == 1:
    if k == 0:
      return 1
    elif k == 1:
      return 0
    elif k == 2:
      return 3
    else:
      return 2

  elif l == 2:
    if k ==0:
      return 2
    elif k == 1:
      return 3
    elif k == 2:
      return 1
    else:
      return 0

  elif l == 3:
    if k == 0:
      return 3
    elif k == 1:
      return 2
    elif k == 2:
      return 0
    else:
      return 1

def create_M_matrix(p1, p2, p3, p4):
    M_matrix = lil_matrix((L**2 * 4, L**2 * 4))
    probs = [p1, p2, p3, p4]
    direction_vectors = {
        0: (0, 1),   #dj = +1
        1: (0, -1),  #dj = -1
        2: (1, 0),   #di = +1
        3: (-1, 0)   #di = -1
    }
    for i in range(L):
        for j in range(L):
            for k in range(4):
                index = coord_to_index(i, j, k)   # find initial index

                #if [i, j] == target_loc:
                if [i, j] == list(target_loc):  # zero out target loc rows
                   continue
                for l in range(4):
                  prob = probs[l]       #choose probability
                  new_k = k_prime(k,l)    #find new velocities
                  di, dj = direction_vectors[new_k]     # find new direction change
                  ni, nj = (i + di) % L, (j + dj) % L   # update position
                  next_index = coord_to_index(ni, nj, new_k)    #convert back to index
                  M_matrix[index, next_index] = prob     #fill matrix with prob to go from (i, j, k) to (i', j', k')



    return M_matrix.tocsr()


target_indices = []
for k in range(4):
  target_indices.append(coord_to_index(target_loc[0], target_loc[1], k))




def M_to_canonical_form(p1,p2,p3,p4):
  M = create_M_matrix(p1, p2, p3, p4)


  transient_indices = []
  for i in range(L**2 * 4):
    if i not in target_indices:
      transient_indices.append(i)   # find transient indices

  reordered_indices = transient_indices + target_indices
  M_reordered = M[reordered_indices, :][:, reordered_indices]

  t_len = len(transient_indices)
  a_len = len(target_indices)

  Q = M_reordered[:t_len, :t_len]
  R = M_reordered[:t_len, t_len:]


  zeros = lil_matrix((a_len, t_len))
  identity = np.identity(a_len)

  top = hstack([Q, R])
  bottom = hstack([zeros, identity])
  canonical = vstack([top, bottom])

  return canonical.tocsr()




def create_Q_matrix(p1, p2, p3, p4):
    M = create_M_matrix(p1, p2, p3, p4)
    #for k in range(4):
     # M[coord_to_index(target_loc[0], target_loc[1], k)] = 0

    transient_indices = []
    for i in range(L**2 * 4):
      if i not in target_indices:
         transient_indices.append(i)   # find transient indices

    reordered_indices = transient_indices + target_indices
    #print(reordered_indices)

    M_reordered = M[reordered_indices, :][:, reordered_indices]
    #print(M_reordered)

    t_len = len(transient_indices)
    a_len = len(target_indices)

    Q = M_reordered[:t_len, :t_len]
    R = M_reordered[:t_len, t_len:]


    zeros = lil_matrix((a_len, t_len))

    identity = np.identity(a_len)

    top = hstack([Q, R])
    bottom = hstack([zeros, identity])
    canonical = vstack([top, bottom])
    return Q.tocsr()


#Q = create_Q_matrix(0.25, 0.25, 0.25, 0.25)
#print(Q.shape)




mu_0 = np.ones(L**2 * 4 - 4)
for i in range(L**2 * 4 - 4):
  if i in target_indices:
    continue
  else:
    mu_0[i] = 1


mu_0 = mu_0 / np.sum(mu_0)


ta = T_max // 750   # set here how long each p1 interval should be

new_T_max = []

def find_time(p):

  switch_times = []   # find times where p1 switches
  for i in range(len(p) - 1):
    switch_times.append((i + 1) * ta)


  Q_matrices = []   #create up to 'p' Q matrices    possibly discretize p1 values to choose from and create Q_matrices outside function to reduce cost???
  for p1 in p:
        p2 = (1 - p1) / 3
        Q = create_Q_matrix(p1, p2, p2, p2)
        Q_matrices.append(Q)

  I = identity(L**2 * 4 - 4, format='csr')
  N = I.copy()
  Q_power = Q_matrices[0].copy()
  segment_index = 0
  for t in range(1, T_max):
    N += Q_power


    if segment_index < len(p) - 1 and t == switch_times[segment_index]:   # find when to switch p1 values
            segment_index += 1

    Q_power = Q_power @ Q_matrices[segment_index]



    if np.sum(Q_power) <= 0.1:      # current form of checking convergence, could be improved possibly?
      print("max t:",t)
      new_T_max.append(t)
      break

  #calculate MFPT
  c = np.ones((L**2 * 4 - 4, 1))
  mfpt = N @ c
  meantime = np.sum(mfpt) / (L**2 * 4)

  #return mfpt
  return meantime

p0 = []
bounds = []
for i in range(30):
  bounds.append((0, 1))
  p0.append(0.66)     #initial guess for all p1(t) values

result = minimize(find_time, p0, method='SLSQP', bounds=bounds)
print("Optimal p1 values:", result.x)
print("Minimized MFPT:", result.fun)

#print("mean of optimal p1 values:", np.mean(result.x))



switch_times = []
for i in range(len(p0)):
    switch_times.append((i + 1) * ta)   # find times that p1 switches

p1t = np.zeros(T_max)   # initialize p1 array
segment = 0
for t in range(T_max):
    if segment < len(p0) and t >= switch_times[segment]:    #
        segment += 1
    p1t[t] = result.x[min(segment, len(p0) - 1)]    #assign p1 values



#newT_max = min(new_T_max)
#print("new T_max:", newT_max)

plt.plot(p1t)
plt.title("p1 over time")
plt.xlabel("time")
plt.ylabel("p1")

plt.show()

import numpy as np
import random
import matplotlib.pyplot as plt


##################################################### STOCHASTIC SIMULATION FOR best_p1 values
#T_max = new_T_max
N = 1000  #Number of walkers
dx = 1      #step space
T_max = 3000

def a(t):
  if t < 1500:
    a = p1t[t]
  else:
    a = 0.6755610561056106
  return a




coordinates = np.arange(L) # creates array from 0 to L
Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows


target_loc = pos_matrix[L // 2,L // 2] # choose target location


Xmatrix = np.zeros((T_max, N, 2))  # (x, y) position matrix
Vmatrix = np.zeros((T_max, N, 2))  # (vx, vy) velocity matrix

# transformation matrices
a_matrix = np.array([[1,0],[0,1]]) # forward
b_matrix = np.array([[-1,0],[0,-1]]) # backward
c_matrix = np.array([[0,-1],[1,0]]) # left
d_matrix = np.array([[0,1],[-1,0]]) # right

# random vinitial function
'''
def vinitial(i):   # chooses initial velocity
  r = random.choice([[0,1],[0,-1],[1,0],[-1,0]])
  return r
'''

'''
#possible tejedor vinitial function?
def vinitial(i):
  if (i) % 4 == 0:
    return np.array([1,0])
  elif (i) % 4 == 1:
    return np.array([-1,0])
  elif (i) % 4 == 2:
    return np.array([0,1])
  else:
    return np.array([0,-1])
'''


# choose initial velocity
def vinitial(i):
  if i == 0:
    d = np.array([1,0]) # +x
  elif i == 1:
    d = np.array([-1,0]) # -x
  elif i == 2:
    d = np.array([0,1]) # +y
  elif i == 3:
    d = np.array([0,-1]) # -y
  return d





# velocity update version 3 (tejedor)
def v_t(prev_v, p_1):
    r = random.random()

    p_2 = (1 - p_1)/3
    p_3 = p_2



    if r < p_1:
      R = a_matrix  # move forward
    elif r < p_1 + p_2:
      R = b_matrix  # move backward
    elif  r < p_1 + p_2 + p_3:
      R = c_matrix  # turn left
    else:
      R = d_matrix  # turn right

    v = R @ np.array(prev_v)
    return v




# position update function
def x_pos(pos_i):
    fpt = np.zeros(N) # intitialize first passage times array
    for n in range(N):
        x = np.array(pos_i)
        Xmatrix[0, n] = x # set initial position

        v = np.array(vinitial(0))
        Vmatrix[0, n] = v #initialize initial velocity

        for t in range(1, T_max):

            p1 = a(t)

            v = np.array(v_t(Vmatrix[t-1,n], p1)) #assign velocities
            Vmatrix[t, n] = v

            step = v * dx

            x = x + step # position update
            x = x % L # boundary condition

            Xmatrix[t, n] = x # assign new positions

            if np.array_equal(Xmatrix[t,n], target_loc): # check to see if walker has hit target
                fpt[n] = t # fill array with first passage times
                break # stop the random walk

    return fpt








# run trajectories over all starting positions

mfpt_map = np.zeros([L, L])
all_fpt = []  # initialize list for all FPTs
fptpos = np.zeros([N, L, L])  # store FPTs for each walker at each initial position

for i in range(L):  # x
    for j in range(L):  # y
        start_pos = pos_matrix[i, j]

        if np.array_equal(start_pos, target_loc):  # skip target
            continue

        fpt = x_pos(start_pos)  # run walkers
        fpt = fpt[fpt > 0]  # remove zero (non-hits)

        all_fpt.extend(fpt)  # accumulate valid FPTs


        if len(fpt) == N:
          fptpos[:, i, j] = fpt
          mfpt_map[i,j] = np.mean(fpt)



fig, (plot1, plot2) = plt.subplots(1, 2, figsize=(15, 4)) # subplots



#trajectory plots

'''
for n in range(N):
    plot1.plot(Xmatrix[:, n, 0], Xmatrix[:, n, 1])
plot1.grid(True)
'''

MFPT = np.sum(all_fpt) / (L**2  * N) #calculate mean first passage time over all positions and walkers
'''
alist = []
for t in range(T_max):
  alist.append(a(t))
plot2.plot(range(T_max), alist)
'''

print(f"MFPT: {MFPT}")
print(f"{len(all_fpt)} out of {N * (L**2-1)} walkers found target")

'''
plot1.imshow(mfpt_map.T)
plot1.colorbar(label='MFPT')
plot1.scatter(*target_loc, color='red')
'''

plt.show()

############################### Analytical tejedor computation of static optimal p1 for L

def create_q_matrix(L):
    q_matrix = np.zeros((L, L), dtype=object)
    for n in range(L):
        for m in range(L):
            q_matrix[n, m] = np.array([(2 * np.pi * n) / L, (2 * np.pi * m) / L])
    return q_matrix


def create_A_value(e, L):

  A =  -(e * (L**2 - 1))/(1 - e)
  return A


def create_B_value(e):
  B = (1 + e**2)/(1 - e**2)
  return B


def create_h_matrix(e, q):
    h_matrix = np.zeros((L, L))

    for n in range( L):
        for m in range( L):
            qn = q[n, m][0]
            qm = q[n, m][1]

            if n == 0 and m == 0:
                h_matrix[0, 0] = 0
                continue


            a = (((e - 1)**2) / 2) * (np.cos(qn) / (1 + e**2 - 2 * e * np.cos(qn)))
            b = (((e - 1)**2) / 2) * (np.cos(qm) / (1 + e**2 - 2 * e * np.cos(qm)))


            c = a + b

            h_matrix[n, m] = 1 / (1 - c)
    #print(h_matrix)


    return h_matrix



def Q_sum(e, L):
    q_matrix = create_q_matrix(L)
    h_matrix = create_h_matrix(e, q_matrix)


    sum = np.sum(h_matrix[0,1:L]) + np.sum(h_matrix[1:L, 0]) + np.sum(h_matrix[1:L, 1:L])

    return sum



def TIME(e, L):
    A = create_A_value(e, L)
    B = create_B_value(e)
    q_sum = Q_sum(e, L)
    return  A + B * q_sum

print("ANALYTICAL OPTIMIZATION")
######################################################################## ANALYTICAL OPTIMIZATION




e_params = np.linspace(.49,.6,10000)
e_LIST = []
time_LIST = []

for e in e_params:
  times = TIME(e,L)
  time_LIST.append(times)
  e_LIST.append(e)


minimum_time = min(time_LIST)
minimum_index = time_LIST.index(minimum_time)
minimum_e = e_LIST[minimum_index]

print("L =", L)
print("optimal MFPT:", minimum_time)
print("optimal e:",minimum_e)
print("optimal p1:", (minimum_e*3 + 1)/4)




plt.show()

import numpy as np
import random
import matplotlib.pyplot as plt


##################################################### STOCHASTIC SIMULATION FOR best_p1 values
#T_max = new_T_max
N = 1000  #Number of walkers
dx = 1      #step space
T_max = 3000
def a(t):
  a = (minimum_e*3 + 1)/4




  return a




coordinates = np.arange(L) # creates array from 0 to L
Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows


target_loc = pos_matrix[L // 2,L // 2] # choose target location


Xmatrix = np.zeros((T_max, N, 2))  # (x, y) position matrix
Vmatrix = np.zeros((T_max, N, 2))  # (vx, vy) velocity matrix

# transformation matrices
a_matrix = np.array([[1,0],[0,1]]) # forward
b_matrix = np.array([[-1,0],[0,-1]]) # backward
c_matrix = np.array([[0,-1],[1,0]]) # left
d_matrix = np.array([[0,1],[-1,0]]) # right

# random vinitial function
'''
def vinitial(i):   # chooses initial velocity
  r = random.choice([[0,1],[0,-1],[1,0],[-1,0]])
  return r
'''

'''
#possible tejedor vinitial function?
def vinitial(i):
  if (i) % 4 == 0:
    return np.array([1,0])
  elif (i) % 4 == 1:
    return np.array([-1,0])
  elif (i) % 4 == 2:
    return np.array([0,1])
  else:
    return np.array([0,-1])
'''


# choose initial velocity
def vinitial(i):
  if i == 0:
    d = np.array([1,0]) # +x
  elif i == 1:
    d = np.array([-1,0]) # -x
  elif i == 2:
    d = np.array([0,1]) # +y
  elif i == 3:
    d = np.array([0,-1]) # -y
  return d





# velocity update version 3 (tejedor)
def v_t(prev_v, p_1):
    r = random.random()

    p_2 = (1 - p_1)/3
    p_3 = p_2



    if r < p_1:
      R = a_matrix  # move forward
    elif r < p_1 + p_2:
      R = b_matrix  # move backward
    elif  r < p_1 + p_2 + p_3:
      R = c_matrix  # turn left
    else:
      R = d_matrix  # turn right

    v = R @ np.array(prev_v)
    return v




# position update function
def x_pos(pos_i):
    fpt = np.zeros(N) # intitialize first passage times array
    for n in range(N):
        x = np.array(pos_i)
        Xmatrix[0, n] = x # set initial position

        v = np.array(vinitial(0))
        Vmatrix[0, n] = v #initialize initial velocity

        for t in range(1, T_max):

            p1 = a(t)

            v = np.array(v_t(Vmatrix[t-1,n], p1)) #assign velocities
            Vmatrix[t, n] = v

            step = v * dx

            x = x + step # position update
            x = x % L # boundary condition

            Xmatrix[t, n] = x # assign new positions

            if np.array_equal(Xmatrix[t,n], target_loc): # check to see if walker has hit target
                fpt[n] = t # fill array with first passage times
                break # stop the random walk

    return fpt








# run trajectories over all starting positions

mfpt_map = np.zeros([L, L])
all_fpt = []  # initialize list for all FPTs
fptpos = np.zeros([N, L, L])  # store FPTs for each walker at each initial position

for i in range(L):  # x
    for j in range(L):  # y
        start_pos = pos_matrix[i, j]

        if np.array_equal(start_pos, target_loc):  # skip target
            continue

        fpt = x_pos(start_pos)  # run walkers
        fpt = fpt[fpt > 0]  # remove zero (non-hits)

        all_fpt.extend(fpt)  # accumulate valid FPTs


        if len(fpt) == N:
          fptpos[:, i, j] = fpt
          mfpt_map[i,j] = np.mean(fpt)



fig, (plot1, plot2) = plt.subplots(1, 2, figsize=(15, 4)) # subplots



#trajectory plots

'''
for n in range(N):
    plot1.plot(Xmatrix[:, n, 0], Xmatrix[:, n, 1])
plot1.grid(True)
'''

MFPT = np.sum(all_fpt) / (L**2  * N) #calculate mean first passage time over all positions and walkers

alist = []
for t in range(T_max):
  alist.append(a(t))
plot2.plot(range(T_max), alist, color = 'black', linewidth=2)


print(f"MFPT: {MFPT}")
print(f"{len(all_fpt)} out of {N * (L**2-1)} walkers found target")

'''
plt.figure(figsize=(6, 5))
plt.imshow( mfpt_map.T,  cmap='plasma')
plt.colorbar(label='MFPT')
plt.scatter(*target_loc, color='red')
'''

plt.show()