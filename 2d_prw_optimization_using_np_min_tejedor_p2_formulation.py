# -*- coding: utf-8 -*-
"""2D PRW optimization using np.min Tejedor p2 formulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G3JsRoc0zIDi7pJ7HWXFzcdG0N41C_Tw
"""

import numpy as np
import random
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import math as m

from scipy.sparse import lil_matrix
from scipy.sparse import identity
from scipy.sparse.linalg import spsolve

N = 500  #Number of walkers
L = 10  # Length of lattice
T = 2000   #time steps
dx = 1      #step space
p_1 = .6
#p_2 = (1-p_1)/3
#p_3 = p_2
#p_4 = p_2
p_2 = .2
p_3 = .15
p_4 = .05

probs = [p_1, p_2, p_3, p_4]


coordinates = np.arange(L) # creates array from 0 to L
Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows


target_loc = pos_matrix[L - 1,L - 1] # choose target location

fig, (plot1, plot2) = plt.subplots(1, 2, figsize=(15, 4)) # subplots

################### THEORETICAL ######################


def coord_to_index(i,j,k):
  M = L**2
  if k == 0:
    return j + i * L
  elif k == 1:
    return j + i * L + M
  elif k == 2:
    return j + i * L + 2 * M
  else:
    return j + i * L + 3 * M


def k_prime(k, l):
  if l == 0:
    return k
  elif l == 1:
    if k == 0:
      return 1
    elif k == 1:
      return 0
    elif k == 2:
      return 3
    else:
      return 2

  elif l == 2:
    if k ==0:
      return 2
    elif k == 1:
      return 3
    elif k == 2:
      return 1
    else:
      return 0

  elif l == 3:
    if k == 0:
      return 3
    elif k == 1:
      return 2
    elif k == 2:
      return 0
    else:
      return 1


def create_M_matrix(p1, p2, p3, p4):
    M_matrix = lil_matrix((L**2 * 4, L**2 * 4))
    probs = [p1, p2, p3, p4]

    direction_vectors = {
        0: (0, 1),   #dj = +1
        1: (0, -1),  #dj = -1
        2: (1, 0),   #di = +1
        3: (-1, 0)   #di = -1
    }

    for i in range(L):
        for j in range(L):
            for k in range(4):
                index = coord_to_index(i, j, k)   # find initial index

                #if [i, j] == target_loc:
                if [i, j] == list(target_loc):  # zero out target loc rows
                    continue


                for l in range(4):
                  prob = probs[l]       #choose probability
                  new_k = k_prime(k,l)    #find new velocities

                  di, dj = direction_vectors[new_k]     # find new direction change
                  ni, nj = (i + di) % L, (j + dj) % L   # update position


                  next_index = coord_to_index(ni, nj, new_k)    #convert back to index

                  M_matrix[index, next_index] = prob     #fill matrix with prob to go from (i, j, k) to (i', j', k')


    return M_matrix.tocsr()



#print(M_matrix)







def theory_MFPT(p1, p2, p3, p4):
  A_vector = np.ones((L**2 * 4,1))
  for l in range(4):
    A_vector[target_loc[0] + L * target_loc[1] + l * L**2] = 0



  I = identity(L**2 * 4).tocsr()
  M_matrix = create_M_matrix(p1, p2, p3, p4)


  T_matrix = spsolve(I - M_matrix, A_vector).reshape(-1, 1)

  for l in range(4):
    T_matrix[target_loc[0] + L * target_loc[1] + l * L**2] = L**2   #Kac Theorum

  return T_matrix







########################################################### PLOTTING




lp_norms = []


P1list = []




norm_theory_mfpt = []

'''
p_1 = 0
while p_1 <= .88:
  p_2 = (1 - p_1)/3
  p_3 = p_2
  p_4 = p_2




  P1list.append(p_1)

  theory_mfpt = theory_MFPT(p_1, p_2, p_3, p_4)

  mean_mfpt = np.mean(theory_mfpt)





  M_all_mfpts.append(mean_mfpt)



  p_1 += .01
'''



'''
p1list = []
M_ALL_mfpts = []
p_1 = 0
while p_1 <=.88:
  p_2 = 0
  p_3 = (1 - p_1)/2
  p_4 = p_3



  p1list.append(p_1)





  tory_mfpt = theory_MFPT(p_1, p_2, p_3, p_4)

  MEAN_mfpt = np.mean(tory_mfpt)



  M_ALL_mfpts.append(MEAN_mfpt)



  p_1 += .01
'''
'''
#plot1.scatter(p1list, M_ALL_mfpts, color = (0,0,1), label="MFPT p2 = 0")
plot1.scatter(P1list, M_all_mfpts,color = (1,0,0), label="MFPT")
plot1.set_title("p2 = 0 MFPTS vs. Symmetric Probabilities MFPTS")
plot1.set_xlabel("p1")
plot1.set_ylabel("MFPT")
plot1.legend()

mins = np.min(M_all_mfpts)
idx = np.argmin(M_all_mfpts)
#maxs = np.max(M_all_mfpts)
print(mins)
print(idx)
print(P1list[idx])
'''

indexlist = []
L = 2
while L <= 50:
  p_1 = 0
  coordinates = np.arange(L) # creates array from 0 to L
  Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
  pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows
  target_loc = pos_matrix[L - 1,L - 1] # choose target location
  M_all_mfpts = []





  while p_1 <= .96:
    p_2 = (1 - p_1)/3
    p_3 = p_2
    p_4 = p_2





    P1list.append(p_1)

    theory_mfpt = theory_MFPT(p_1, p_2, p_3, p_4)

    mean_mfpt = np.mean(theory_mfpt)





    M_all_mfpts.append(mean_mfpt)



    p_1 += .001

  indexlist.append(np.argmin(M_all_mfpts))
  #mins = np.min(M_all_mfpts)

  print("For L = ",L)
  #print(mins)
  #print(idx)
  print("Optimal p1 = ",P1list[indexlist[L - 2]])

  L += 1





#plot1.scatter(lp_norms, norm_theory_mfpt, label="Matrix MFPT")
#plot2.scatter(lp_norms, M_all_mfpts,color = (1,0,0), label="Matrix MFPT")
#plot2.set_title("Non-Normalized Matrix Computed MFPTS vs. Approximation Equation")
#plot1.set_title("Non-Normalized Matrix Computed and Simulated MFPTS vs. Approximation Equation ")
#plot2.set_xlabel("lp / L")
#plot2.set_ylabel("MFPT / MFPT_0")
#plot2.set_ylabel("MFPT")





plt.show()