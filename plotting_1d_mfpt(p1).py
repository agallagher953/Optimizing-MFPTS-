# -*- coding: utf-8 -*-
"""plotting 1D MFPT(p1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yPlejrlCzjhSI4-0uduGojvglpc6pjUN
"""

import numpy as np
import random
import matplotlib.pyplot as plt


N = 10000  #Number of walkers
L = 10   #Total space
T = 10000    #time steps
x_0 = 0   #Initial position
dx = 1    # step size
a = .5    # persistance level



Vmatrix = np.zeros((T, N)) # velocity matrix
Xmatrix = np.zeros((T, N)) # position matrix

target_loc = L - 1  # choose target location here
#print(f"target location: {target_loc}")
'''
def vinitial(i):   # chooses initial velocity
  r = random.random()
  if r > .5:
    return 1
  else:
    return -1
'''
'''
# equal number of v_initial directions
def vinitial(i):
  if (i) % 2 == 0:
    return 1
  else:
    return -1
'''




# first half of N walkers have v_i = +1
def vinitial(i):
  up = 1
  down = -1

  if i < N//2:
    return down
  else:
    return up



def v_t(prev_v): # determine new v
  r = random.random()
  if r < a:
    v = prev_v
  else:
    v = -prev_v

  return v




def x_pos(pos_i):
    fpt = np.zeros(N) # first passage times
    for n in range(N):
        x = int(pos_i)
        Xmatrix[0, n] = x # set initial position

        v = vinitial(n)
        Vmatrix[0, n] = v #initialize initial velocity

        for t in range(1, T):


            v = np.array(v_t(Vmatrix[t-1,n])) #assign velocities
            Vmatrix[t, n] = v

            step = v * dx

            x = x + step # position update


            if x >= L:  # periodic boundary conditions
                x -= L
            elif x < 0:
                x += L

            Xmatrix[t, n] = x # assign new positions

            if x == target_loc: # check to see if walker has hit target
                fpt[n] = t # fill array with first passage times
                break
    return fpt



fig, (plot1, plot2) = plt.subplots(1, 2, figsize=(15, 4)) # subplots
fig, (plot3, plot4) = plt.subplots(1, 2, figsize=(15, 4)) # 2nd set of subplots


################################
#     Theoretical MFPT

T_matrix = np.zeros((2*L,1))    #MFPT vector
for i in range(L):
  T_matrix[i] = i
  T_matrix[i+L] = i
T_matrix[target_loc] =  0
T_matrix[target_loc+L] =  0

#print(T_matrix)


trans_matrix = np.zeros((2*L, 2*L))
for l in range(L):
  trans_matrix[l,(l+1) % L] = a   # +x (top left)
  trans_matrix[(l+1) % L,l + L] = (1 - a)   # -x (top right)    switch direction
  trans_matrix[l + L,(l+1) % L] = (1 - a)   # +x (bottom left)   switch direction
  trans_matrix[(l+1) % L + L,l + L] = a   # -x (bottom right)
trans_matrix[target_loc,:] = 0
trans_matrix[target_loc+L,:] = 0


#print(trans_matrix)

A_vector = np.ones((2 * L, 1))
A_vector[target_loc] = 0
A_vector[target_loc+L] = 0

#print(A_vector)


#print(T_matrix)


I = np.eye(2 * L)



T_matrix = np.linalg.solve(I - trans_matrix, A_vector)
T_matrix[target_loc] = L    #Kac theorum
T_matrix[target_loc+L] = L    #Kac Theorum
#print(T_matrix)




####### stochastic MFPT
FPTS = []
for i in range(L):
  #if i == target_loc:  # skip target
   # continue

  fpt = x_pos(i)
  fpt = fpt[fpt > 0]
  FPTS.extend(fpt)







########################################### global MFPT print statements
#global_mfpt_theory_v_neg = np.mean(T_matrix[0:L])
global_mfpt_theory_v_neg = (np.sum(T_matrix[0:L]) / len(T_matrix[0:L]))
print(f"Theory Global MFPT with v_initial = -1: {global_mfpt_theory_v_neg}")



mfptsn = []
for i in range(L):
  mfptsn.append(FPTS[i * N: i * N + N//2])
MFPTSN = np.mean(mfptsn)
print(f"Stochastic Global MFPT with v_initial = -1: {MFPTSN}")


global_mfpt_theory_v_pos = np.mean(T_matrix[L:2*L])
print(f"Theory Global MFPT with v_initial = +1: {global_mfpt_theory_v_pos}")

mfptsp = []
for i in range(L):
  mfptsp.append(FPTS[i * N + N//2: i * N + N])
MFPTSP = np.mean(mfptsp)

print(f"Stochastic Global MFPT with v_initial = +1: {MFPTSP}")




print(T_matrix)













############################## graphing MFPTS(a)
a = .5
all_mfpts_theory = []
while a <= 1:


  for l in range(L):
    trans_matrix[l,(l+1) % L] = a   # +x (top left)
    trans_matrix[(l+1) % L,l + L] = (1 - a)   # -x (top right)    switch direction
    trans_matrix[l + L,(l+1) % L] = (1 - a)   # +x (bottom left)   switch direction
    trans_matrix[(l+1) % L + L,l + L] = a   # -x (bottom right)
  trans_matrix[target_loc,:] = 0
  trans_matrix[target_loc+L,:] = 0



  T_matrix = np.linalg.solve(I - trans_matrix, A_vector)
  T_matrix[target_loc] = L    #Kac theorum
  T_matrix[target_loc+L] = L


  all_mfpts_theory.append(np.mean(T_matrix))

  for n in range(len(all_mfpts_theory)):
    y = all_mfpts_theory[n] / all_mfpts_theory[0]
    x = a

  plot3.scatter(x,y)

  plot3.set_xlabel("a")
  plot3.set_ylabel("MFPT / MFPT_0")
  plot3.set_title("1D MFPT(a)")


  a += .01







a = .5


# MFPT(a) graph
all_mfpts = []
while a <= 1:
  all_fpts = []
  for i in range(L):


    fpt = x_pos(i)
    fpt = fpt[fpt > 0]
    all_fpts.extend(fpt)

  MFPT = np.mean(all_fpts)

  all_mfpts.append(MFPT)

  for n in range(len(all_mfpts)):
    y = all_mfpts[n] / all_mfpts[0]
  x = a


  plot3.scatter(x,y)

  plot3.set_xlabel("a")
  plot3.set_ylabel("MFPT / MFPT_0")
  plot3.set_title("1D MFPT(a)")

  a += .01


plt.show()