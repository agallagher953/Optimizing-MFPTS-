# -*- coding: utf-8 -*-
"""Measuring MFPTS of the Tejedor optimal p1 values.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16hgCP20wBECjDi9jfTVgK7W3wgqUcFNJ
"""

import numpy as np
import random
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import math as m

from scipy.sparse import lil_matrix
from scipy.sparse import identity
from scipy.sparse.linalg import spsolve

N = 100  #Number of walkers
L = 10   # Length of lattice
T = 99999999   #time steps
dx = 1      #step space
a = .5      # persistence level
p_1 = 0.6756479531224381    # prob to go forwards
p_2 = (1 - p_1)/3    # prob to go backwards
p_3 = p_2    # prob to turn left
p_4 = p_2    # prob to turn right
e = 0

coordinates = np.arange(L) # creates array from 0 to L
Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows


target_loc = pos_matrix[2,2] # choose target location



fig, (plot1, plot2) = plt.subplots(1, 2, figsize=(15, 4)) # subplots
fig, (plot3, plot4) = plt.subplots(1, 2, figsize=(15, 4)) # 2nd set of subplots







def coord_to_index(i,j,k):
  M = L**2
  if k == 0:
    return j + i * L
  elif k == 1:
    return j + i * L + M
  elif k == 2:
    return j + i * L + 2 * M
  else:
    return j + i * L + 3 * M


def k_prime(k, l):
  if l == 0:
    return k
  elif l == 1:
    if k == 0:
      return 1
    elif k == 1:
      return 0
    elif k == 2:
      return 3
    else:
      return 2

  elif l == 2:
    if k ==0:
      return 2
    elif k == 1:
      return 3
    elif k == 2:
      return 1
    else:
      return 0

  elif l == 3:
    if k == 0:
      return 3
    elif k == 1:
      return 2
    elif k == 2:
      return 0
    else:
      return 1


def create_M_matrix(p1, p2, p3, p4):
    M_matrix = lil_matrix((L**2 * 4, L**2 * 4))
    probs = [p1, p2, p3, p4]

    direction_vectors = {
        0: (0, 1),   #dj = +1
        1: (0, -1),  #dj = -1
        2: (1, 0),   #di = +1
        3: (-1, 0)   #di = -1
    }

    for i in range(L):
        for j in range(L):
            for k in range(4):
                index = coord_to_index(i, j, k)   # find initial index

                #if [i, j] == target_loc:
                if [i, j] == list(target_loc):  # zero out target loc rows
                    continue


                for l in range(4):
                  prob = probs[l]       #choose probability
                  new_k = k_prime(k,l)    #find new velocities

                  di, dj = direction_vectors[new_k]     # find new direction change
                  ni, nj = (i + di) % L, (j + dj) % L   # update position


                  next_index = coord_to_index(ni, nj, new_k)    #convert back to index

                  M_matrix[index, next_index] = prob     #fill matrix with prob to go from (i, j, k) to (i', j', k')


    return M_matrix.tocsr()



#print(M_matrix)







def theory_MFPT(p1, p2, p3, p4):
  A_vector = np.ones((L**2 * 4,1))
  for l in range(4):
    A_vector[target_loc[0] + L * target_loc[1] + l * L**2] = 0



  I = identity(L**2 * 4).tocsr()
  M_matrix = create_M_matrix(p1, p2, p3, p4)


  T_matrix = spsolve(I - M_matrix, A_vector).reshape(-1, 1)

  for l in range(4):
    T_matrix[target_loc[0] + L * target_loc[1] + l * L**2] = 0   #Kac Theorum

  return T_matrix








def opt_p1(L):
  p1_opts = []
  for i in range(10,L):
    p1_opt = - 1 / (.14 * i) + 1
    p1_opts.append(p1_opt)
  return p1_opts


max_L = 50
mfpts = []
p1s = opt_p1(max_L)

print(p1s)


L = 10
while L <= max_L:



  coordinates = np.arange(L) # creates array from 0 to L
  Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
  pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows


  target_loc = pos_matrix[L - 1,L -1 ] # choose target location

  p1 = p1s[L-11]
  p2 = (1 - p1)/3
  p3 = p2
  p4 = p2

  T_matrix = theory_MFPT(p1, p2, p3, p4)
  mfpt = np.mean(T_matrix)
  mfpts.append(mfpt)

  print(f'L = {L}, MFPT = {mfpt}, optimal p1 = {p1s[L - 11]}')


  L += 1



################################# equation 7

def create_q_matrix(L):
    q_matrix = np.zeros((L, L), dtype=object)
    for n in range(L):
        for m in range(L):
            q_matrix[n, m] = np.array([(2 * np.pi * n) / L, (2 * np.pi * m) / L])
    return q_matrix


def create_A_value(e, L):

  A =  -(e * (L**2 - 1))/(1 - e)
  return A


def create_B_value(e):
  B = (1 + e**2)/(1 - e**2)
  return B


def create_h_matrix(e, q):
    h_matrix = np.zeros((L, L))

    for n in range( L):
        for m in range( L):
            qn = q[n, m][0]
            qm = q[n, m][1]

            if n == 0 and m == 0:
                h_matrix[0, 0] = 0
                continue


            a = (((e - 1)**2) / 2) * (np.cos(qn) / (1 + e**2 - 2 * e * np.cos(qn)))
            b = (((e - 1)**2) / 2) * (np.cos(qm) / (1 + e**2 - 2 * e * np.cos(qm)))


            c = a + b

            h_matrix[n, m] = 1 / (1 - c)
    #print(h_matrix)


    return h_matrix



def Q_sum(e, L):
    q_matrix = create_q_matrix(L)
    h_matrix = create_h_matrix(e, q_matrix)


    sum = np.sum(h_matrix[0,1:L]) + np.sum(h_matrix[1:L, 0]) + np.sum(h_matrix[1:L, 1:L])

    return sum



def TIME(e, L):
    A = create_A_value(e, L)
    B = create_B_value(e)
    q_sum = Q_sum(e, L)
    return  A + B * q_sum


L = 10
e = 0

L_list =[]
indexlist = []
optp1_list = []
min_time_list = []
while L <= 50:
  e = 0
  L_list.append(L)

  e_list = []
  p1_list = []
  time_list = []

  while e <= .97:

    p1 = (1 + 3 * e)/4
    p2 = (1 - p1)/3

    #p2 = (1 - e)/4
    #p1 = p2 + e


    probs = [p1, p2, p2, p2]

    #print(np.sum(probs))

    p1_list.append(p1)


    time = TIME(e, L)
    time_list.append(time)

    e_list.append(e)
    e += .001

  indexlist.append(np.argmin(time_list))
  min_time_list.append(min(time_list))


  optp1_list.append(p1_list[indexlist[L-10]])

  #print("optimal e",e_list[indexlist[L-2]])


  print("L =", L)
  print("optimal MFPT:", min(time_list))
  print("optimal p1",p1_list[indexlist[L-10]])
  L += 1


plot1.scatter(L_list, min_time_list, label = "eq. 7 MFPTS")
plot1.set_xlabel("L")
plot1.set_ylabel("MFPT")















plot1.scatter(L_list, mfpts, label = "scaling law MFPTS")
plot1.legend()






plt.show()