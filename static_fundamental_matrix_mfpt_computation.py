# -*- coding: utf-8 -*-
"""static fundamental matrix MFPT computation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D7l9hGf4Lx1iVf46epUPCiqz7illfYO-
"""

# Analytical tejedor computation of static optimal p1 for L
L = 10


def create_q_matrix(L):
    q_matrix = np.zeros((L, L), dtype=object)
    for n in range(L):
        for m in range(L):
            q_matrix[n, m] = np.array([(2 * np.pi * n) / L, (2 * np.pi * m) / L])
    return q_matrix


def create_A_value(e, L):

  A =  -(e * (L**2 - 1))/(1 - e)
  return A


def create_B_value(e):
  B = (1 + e**2)/(1 - e**2)
  return B


def create_h_matrix(e, q):
    h_matrix = np.zeros((L, L))

    for n in range( L):
        for m in range( L):
            qn = q[n, m][0]
            qm = q[n, m][1]

            if n == 0 and m == 0:
                h_matrix[0, 0] = 0
                continue


            a = (((e - 1)**2) / 2) * (np.cos(qn) / (1 + e**2 - 2 * e * np.cos(qn)))
            b = (((e - 1)**2) / 2) * (np.cos(qm) / (1 + e**2 - 2 * e * np.cos(qm)))


            c = a + b

            h_matrix[n, m] = 1 / (1 - c)
    #print(h_matrix)


    return h_matrix



def Q_sum(e, L):
    q_matrix = create_q_matrix(L)
    h_matrix = create_h_matrix(e, q_matrix)


    sum = np.sum(h_matrix[0,1:L]) + np.sum(h_matrix[1:L, 0]) + np.sum(h_matrix[1:L, 1:L])

    return sum



def TIME(e, L):
    A = create_A_value(e, L)
    B = create_B_value(e)
    q_sum = Q_sum(e, L)
    return  A + B * q_sum

print("ANALYTICAL OPTIMIZATION")
######################################################################## ANALYTICAL OPTIMIZATION




e_params = np.linspace(.49,.6,1000)
e_LIST = []
time_LIST = []

for e in e_params:
  times = TIME(e,L)
  time_LIST.append(times)
  e_LIST.append(e)


minimum_time = min(time_LIST)
minimum_index = time_LIST.index(minimum_time)
minimum_e = e_LIST[minimum_index]

print("L =", L)
print("optimal MFPT:", minimum_time)
print("optimal e:",minimum_e)
print("optimal p1:", (minimum_e*3 + 1)/4)




plt.show()

import numpy as np
import random
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import math as m

from scipy.sparse import lil_matrix
from scipy.sparse import identity
from scipy.sparse.linalg import spsolve
from scipy.sparse import lil_matrix, csr_matrix, vstack, hstack, identity


T_max = 2000
coordinates = np.arange(L) # creates array from 0 to L
Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows


target_loc = pos_matrix[L // 2,L // 2]

# Create transition matrix functions

def coord_to_index(i,j,k):
  M = L**2
  if k == 0:
    return j + i * L
  elif k == 1:
    return j + i * L + M
  elif k == 2:
    return j + i * L + 2 * M
  else:
    return j + i * L + 3 * M


def k_prime(k, l):
  if l == 0:
    return k
  elif l == 1:
    if k == 0:
      return 1
    elif k == 1:
      return 0
    elif k == 2:
      return 3
    else:
      return 2

  elif l == 2:
    if k ==0:
      return 2
    elif k == 1:
      return 3
    elif k == 2:
      return 1
    else:
      return 0

  elif l == 3:
    if k == 0:
      return 3
    elif k == 1:
      return 2
    elif k == 2:
      return 0
    else:
      return 1

def create_M_matrix(p1, p2, p3, p4):
    M_matrix = lil_matrix((L**2 * 4, L**2 * 4))
    probs = [p1, p2, p3, p4]
    direction_vectors = {
        0: (0, 1),   #dj = +1
        1: (0, -1),  #dj = -1
        2: (1, 0),   #di = +1
        3: (-1, 0)   #di = -1
    }
    for i in range(L):
        for j in range(L):
            for k in range(4):
                index = coord_to_index(i, j, k)   # find initial index

                #if [i, j] == target_loc:
                if [i, j] == list(target_loc):  # zero out target loc rows
                   continue
                for l in range(4):
                  prob = probs[l]       #choose probability
                  new_k = k_prime(k,l)    #find new velocities
                  di, dj = direction_vectors[new_k]     # find new direction change
                  ni, nj = (i + di) % L, (j + dj) % L   # update position
                  next_index = coord_to_index(ni, nj, new_k)    #convert back to index
                  M_matrix[index, next_index] = prob     #fill matrix with prob to go from (i, j, k) to (i', j', k')



    return M_matrix.tocsr()


target_indices = []
for k in range(4):
  target_indices.append(coord_to_index(target_loc[0], target_loc[1], k))




def M_to_canonical_form(p1,p2,p3,p4):
    M = create_M_matrix(p1, p2, p3, p4)


    transient_indices = []
    for i in range(L**2 * 4):
      if i not in target_indices:
        transient_indices.append(i)

    reordered_indices = transient_indices + target_indices
    #print(reordered_indices)

    M_reordered = M[reordered_indices, :][:, reordered_indices]

    t_len = len(transient_indices)
    a_len = len(target_indices)


    Q = M_reordered[:t_len, :t_len]
    R = M_reordered[:t_len, t_len:]
    zero_block = lil_matrix((a_len, t_len))
    identity_block = identity(a_len)

    top = hstack([Q, R])
    bottom = hstack([zero_block, identity_block])
    canonical = vstack([top, bottom])

    return canonical.tocsr()




def create_Q_matrix(p1, p2, p3, p4):
    M = create_M_matrix(p1, p2, p3, p4)



    transient_indices = []
    for i in range(L**2 * 4):
      if i not in target_indices:
        transient_indices.append(i)

    reordered_indices = transient_indices + target_indices
    #print(reordered_indices)

    M_reordered = M[reordered_indices, :][:, reordered_indices]
    #print(M_reordered)

    t_len = len(transient_indices)
    a_len = len(target_indices)


    Q = M_reordered[:t_len, :t_len]
    R = M_reordered[:t_len, t_len:]
    zero_block = lil_matrix((a_len, t_len))
    identity_block = identity(a_len)

    top = hstack([Q, R])
    bottom = hstack([zero_block, identity_block])
    canonical = vstack([top, bottom])

    return Q.tocsr()


#Q = create_Q_matrix(0.25, 0.25, 0.25, 0.25)
#print(Q.shape)



'''
mu_0 = np.ones(L**2 * 4 - 4)
for i in range(L**2 * 4 - 4):
  if i in target_indices:
    continue
  else:
    mu_0[i] = 1


mu_0 = mu_0 / np.sum(mu_0)
'''


def find_time(p):

  p2 = (1 - p) / 3
  Q = create_Q_matrix(p, p2, p2, p2)


  I = identity(L**2 * 4 - 4).tocsr()
  N = I.copy()
  Q_power = Q
  for t in range(1, T_max):
     N += Q_power
     Q_power = Q_power @ Q


  c = np.ones((L**2 * 4 - 4, 1))
  mfpt = N @ c
  meantime = np.sum(mfpt) / (L**2 * 4)

  #return mfpt
  return meantime


print(find_time((minimum_e*3 + 1)/4))







#120.91920974216796
plt.show()