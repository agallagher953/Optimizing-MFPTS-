# -*- coding: utf-8 -*-
"""find global p1(t) from MDP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mAJmhMWvWR-0t54ot_sAPb1aGnQ_N9xq
"""

####################### MDP ON ALL STATES
import numpy as np
import random
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import math as m

from scipy.sparse import csr_matrix
from scipy.sparse import lil_matrix
from scipy.sparse import identity
from scipy.sparse.linalg import spsolve


#fig, (plot1, plot2) = plt.subplots(1, 2, figsize=(15, 4)) # subplots


L = 5
T_max = 20
coordinates = np.arange(L) # creates array from 0 to L
Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows


target_loc = pos_matrix[L // 2,L // 2]

# Create transition matrix functions

def coord_to_index(i,j,k):
  M = L**2
  if k == 0:
    return j + i * L
  elif k == 1:
    return j + i * L + M
  elif k == 2:
    return j + i * L + 2 * M
  else:
    return j + i * L + 3 * M


def k_prime(k, l):
  if l == 0:
    return k
  elif l == 1:
    if k == 0:
      return 1
    elif k == 1:
      return 0
    elif k == 2:
      return 3
    else:
      return 2

  elif l == 2:
    if k ==0:
      return 2
    elif k == 1:
      return 3
    elif k == 2:
      return 1
    else:
      return 0

  elif l == 3:
    if k == 0:
      return 3
    elif k == 1:
      return 2
    elif k == 2:
      return 0
    else:
      return 1

def create_M_matrix(p1, p2, p3, p4):
    M_matrix = lil_matrix((L**2 * 4, L**2 * 4))
    probs = [p1, p2, p3, p4]
    direction_vectors = {
        0: (0, 1),   #dj = +1
        1: (0, -1),  #dj = -1
        2: (1, 0),   #di = +1
        3: (-1, 0)   #di = -1
    }
    for i in range(L):
        for j in range(L):
            for k in range(4):
                index = coord_to_index(i, j, k)   # find initial index

                #if [i, j] == target_loc:
                if [i, j] == list(target_loc):  # zero out target loc rows
                   continue
                for l in range(4):
                  prob = probs[l]       #choose probability
                  new_k = k_prime(k,l)    #find new velocities
                  di, dj = direction_vectors[new_k]     # find new direction change
                  ni, nj = (i + di) % L, (j + dj) % L   # update position
                  next_index = coord_to_index(ni, nj, new_k)    #convert back to index
                  M_matrix[index, next_index] = prob     #fill matrix with prob to go from (i, j, k) to (i', j', k')
    return M_matrix.tocsr()

### MDP

target_indices = []
for k in range(4):
  target_indices.append(coord_to_index(target_loc[0], target_loc[1], k))

V = np.zeros((T_max + 1, L**2 * 4))   # value function initialization


mu_0 = np.ones(L**2 * 4)
mu_0[target_indices] = 0
mu_0 = mu_0 / np.sum(mu_0) # inital state
#print(mu_0)


# Backward Recursion
best_probs = np.zeros((T_max,L**2 * 4), dtype = tuple)    # time X number of states



def create_probs(dp):      #create combinations of probabilities to try
  probs = []
  for p1 in np.arange(0, 1+dp, dp):
        for p2 in np.arange(0, 1+dp, dp):
            for p3 in np.arange(0, 1+dp, dp):
                p4 = 1 - p1 - p2 - p3
                if 0 <= p4 <= 1:
                    probs.append((p1, p2, p3, p4))
  return probs


M_matrices = {}  # Store M matrices for each p1 value
probs = create_probs(1)

for p in probs:
    p1, p2, p3, p4 = p
    M_matrices[p] = create_M_matrix(p1, p2, p3, p4)



one_vector = np.ones(L**2 * 4)
one_vector[target_indices] = 0    # skip target state???


##################### Value iteration of bellman equation
for t in reversed(range(T_max)):

  for s in range(L**2 * 4):
    best_cost = 1e9
    if s in target_indices:
      continue

    for p in probs:
      M = M_matrices[p]


      #Q[s] = one_vector + (M @ V[t + 1].reshape(-1, 1)).flatten()      # Bellman equation iteration
      Q = one_vector + M @ V[t + 1]


      E_T = Q[s]



      if E_T < best_cost: # Minimization, find the minimum expected MFPT
          best_cost = E_T   # set best cost to expected cost to compare different expected MFPT(p1)
          V[t,s] = Q[s]  # Update V[t] with the Q that gives the minimum cost
          best_probs[t,s] = p # sets best_p1 with the p1 which gives the minimum expected cost
          #print(best_cost)


def find_fpt(state_index):
    return mu_0[state_index] * V[0, state_index]





global_probs = np.zeros(T_max, dtype = tuple)

'''
def find_prob_mass():
    mu_t = np.zeros((T_max, L**2 * 4))    # all states all time
    mu_t[0] = mu_0
    mu_t_sum = [np.sum(mu_0)]


    probbabs = np.zeros((T_max, 4))
    for t in range(1, T_max):

        row_indices = []
        col_indices = []
        data = []

        for i in range(L):
            for j in range(L):
                for k in range(4):
                    s = coord_to_index(i, j, k)   #s = all states
                    if s in target_indices:
                        continue

                    p = best_probs[t, s]      # call best p1(t,s)

                    p1, p2, p3, p4 = p
                    direction_vectors = {
                        0: (0, 1), 1: (0, -1), 2: (1, 0), 3: (-1, 0)
                    }

                    for l in range(4):
                        new_k = k_prime(k, l)
                        di, dj = direction_vectors[new_k]
                        ni, nj = (i + di) % L, (j + dj) % L
                        next_s = coord_to_index(ni, nj, new_k)

                        row_indices.append(s)
                        col_indices.append(next_s)
                        data.append(p[l])

        M_t = csr_matrix((data, (row_indices, col_indices)), shape=(L**2 * 4, L**2 * 4))

        #print(M_t)
        mu_t[t] = M_t @ mu_t[t-1]
        mu_t[t, target_indices] = 0

        mu_t_sum.append(np.sum(mu_t[t]))





        ps = np.zeros(4)

        for i in range(L):
          for j in range(L):
            for k in range(4):
              s = coord_to_index(i,j,k)
              for l in range(4):

                ps[l] = mu_t[t,s] * best_probs[t,s][l]

                probbabs[t,l] += ps[l]


    return mu_t_sum, probbabs



'''

def find_prob_mass():
    mu_t = np.zeros((T_max, L**2 * 4))    # all states all time
    mu_t[0] = mu_0
    mu_t_sum = [np.sum(mu_0)]

    probbabs = np.zeros((T_max, 4))  # <- move this OUTSIDE the loop

    for t in range(1, T_max):

        row_indices = []
        col_indices = []
        data = []

        for i in range(L):
            for j in range(L):
                for k in range(4):
                    s = coord_to_index(i, j, k)
                    if s in target_indices:
                        continue

                    p = best_probs[t, s]
                    direction_vectors = {
                        0: (0, 1), 1: (0, -1), 2: (1, 0), 3: (-1, 0)
                    }

                    for l in range(4):
                        new_k = k_prime(k, l)
                        di, dj = direction_vectors[new_k]
                        ni, nj = (i + di) % L, (j + dj) % L
                        next_s = coord_to_index(ni, nj, new_k)

                        row_indices.append(s)
                        col_indices.append(next_s)
                        data.append(p[l])

        M_t = csr_matrix((data, (row_indices, col_indices)), shape=(L**2 * 4, L**2 * 4))
        mu_t[t] = M_t @ mu_t[t-1]
        mu_t[t, target_indices] = 0
        mu_t_sum.append(np.sum(mu_t[t]))

        # Compute weighted probs at time t
        for i in range(L):
            for j in range(L):
                for k in range(4):
                    s = coord_to_index(i, j, k)
                    if isinstance(best_probs[t, s], (tuple, list)):
                      for l in range(4):
                        probbabs[t, l] += mu_t[t, s] * best_probs[t, s][l]

    return mu_t_sum, probbabs












#print(find_prob_mass())
probmass, probabs = find_prob_mass()

'''
# plotting
plt.figure(figsize=(8, 5))

plt.plot(range(T_max), probs[:,0], label = 'p1')

plt.plot(range(T_max), probs[:,1], label = 'p2')

plt.plot(range(T_max), probs[:,2], label = 'p3')

plt.plot(range(T_max), probs[:,3], label = 'p4')

plt.legend()

plt.show()
'''

plt.figure(figsize=(8, 5))

plt.plot(range(T_max), probabs[:, 0], label='p1')
plt.legend()
plt.show()

plt.plot(range(T_max), probabs[:, 1], label='p2')
plt.legend()
plt.show()
plt.plot(range(T_max), probabs[:, 2], label='p3')
plt.legend()
plt.show()
plt.plot(range(T_max), probabs[:, 3], label='p4')
plt.legend()
plt.show()
'''
plt.xlabel("Time step")
plt.ylabel("Weighted average action probability")
plt.title("Weighted average probabilities over time")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

'''









### plot probability mass

'''
plot2.plot(probmass, label = 'Probability In Transient States')
plot2.set_title(f"Probability In Transient States Over Time")
plot2.set_xlabel("Time")
plot2.set_ylabel("Probability")
plt.legend()

'''





MFPT = 0



for i in range(L):
    for j in range(L):
        for k in range(4):
            s = coord_to_index(i, j, k)
            MFPT += mu_0[s] * V[0, s]



print("MFPT:", MFPT)





plt.show()