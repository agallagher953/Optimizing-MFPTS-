# -*- coding: utf-8 -*-
"""Optimization Problem with control vector (cvxpy).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11p7ND44__W_D0HV4Qpa6DhtvYFX15vSJ
"""

import numpy as np
import random
import matplotlib.pyplot as plt
from scipy.optimize import minimize
import cvxpy as cp

L = 10       # choose number of elements in array

l_step = 5

initial_state = np.ones(L)

initial_state[0:L] = random.random()

print("initial state:",initial_state)



p1 = .2
p2 = .7

target_state = np.ones(L)    # initialize target state array
target_state[0:l_step] = p1
target_state[l_step:L] = p2
print("target state:", target_state)



def step_function(u, x):
    x_1 = np.zeros(L)
    x_1[0:l_step] = x[0:l_step]
    x_2 = np.zeros(L)
    x_2[l_step:L] = x[l_step:L]

    return cp.multiply(u[0], x_1) + cp.multiply(u[1], x_2)






def cost_function(u, x, f_eq):
    f_x = step_function(u, x)
    return cp.sum_squares(f_x - f_eq)





u_vals = cp.Variable(2)


objective = cp.Minimize(cost_function(u_vals, initial_state, target_state))




constraints = [
    #cp.sum(cp.multiply(u_vals, initial_state)) == 1,  # normalization
    u_vals >= 0,
    u_vals <= 1
]




prob = cp.Problem(objective, constraints)
prob.solve()



print("optimized scalar value a:", u_vals[0].value)
print("optimized scalar value b:", u_vals[1].value)
print("cost:", prob.value)

#print("normalization:", np.sum((u_vals.value * initial_state)))
print(prob.solver_stats.solver_name)




plt.show()