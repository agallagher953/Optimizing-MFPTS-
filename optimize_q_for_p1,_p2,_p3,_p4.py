# -*- coding: utf-8 -*-
"""Optimize Q for p1, p2, p3, p4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12JbnHpz8Gg04417xmT2X8jXHW7w1tCxS
"""

import numpy as np
import random
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import math as m

from scipy.sparse import lil_matrix
from scipy.sparse import identity
from scipy.sparse.linalg import spsolve
from scipy.sparse import lil_matrix, csr_matrix, vstack, hstack, identity
from scipy.sparse.linalg import norm
L = 15
T_max = 100
coordinates = np.arange(L) # creates array from 0 to L
Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows


target_loc = pos_matrix[L // 2,L // 2]

# Create transition matrix functions

def coord_to_index(i,j,k):
  M = L**2
  if k == 0:
    return j + i * L
  elif k == 1:
    return j + i * L + M
  elif k == 2:
    return j + i * L + 2 * M
  else:
    return j + i * L + 3 * M


def k_prime(k, l):
  if l == 0:
    return k
  elif l == 1:
    if k == 0:
      return 1
    elif k == 1:
      return 0
    elif k == 2:
      return 3
    else:
      return 2

  elif l == 2:
    if k ==0:
      return 2
    elif k == 1:
      return 3
    elif k == 2:
      return 1
    else:
      return 0

  elif l == 3:
    if k == 0:
      return 3
    elif k == 1:
      return 2
    elif k == 2:
      return 0
    else:
      return 1

def create_M_matrix(p1, p2, p3, p4):
    M_matrix = lil_matrix((L**2 * 4, L**2 * 4))
    probs = [p1, p2, p3, p4]
    direction_vectors = {
        0: (0, 1),   #dj = +1
        1: (0, -1),  #dj = -1
        2: (1, 0),   #di = +1
        3: (-1, 0)   #di = -1
    }
    for i in range(L):
        for j in range(L):
            for k in range(4):
                index = coord_to_index(i, j, k)   # find initial index

                #if [i, j] == target_loc:
                if [i, j] == list(target_loc):  # zero out target loc rows
                   continue
                for l in range(4):
                  prob = probs[l]       #choose probability
                  new_k = k_prime(k,l)    #find new velocities
                  di, dj = direction_vectors[new_k]     # find new direction change
                  ni, nj = (i + di) % L, (j + dj) % L   # update position
                  next_index = coord_to_index(ni, nj, new_k)    #convert back to index
                  M_matrix[index, next_index] = prob     #fill matrix with prob to go from (i, j, k) to (i', j', k')



    return M_matrix.tocsr()


target_indices = []
for k in range(4):
  target_indices.append(coord_to_index(target_loc[0], target_loc[1], k))

def create_Q_matrix(p1, p2, p3, p4):
    M = create_M_matrix(p1, p2, p3, p4)
    #for k in range(4):
     # M[coord_to_index(target_loc[0], target_loc[1], k)] = 0

    transient_indices = []
    for i in range(L**2 * 4):
      if i not in target_indices:
         transient_indices.append(i)   # find transient indices

    reordered_indices = transient_indices + target_indices
    #print(reordered_indices)

    M_reordered = M[reordered_indices, :][:, reordered_indices]
    #print(M_reordered)

    t_len = len(transient_indices)
    a_len = len(target_indices)

    Q = M_reordered[:t_len, :t_len]
    R = M_reordered[:t_len, t_len:]


    zeros = lil_matrix((a_len, t_len))

    identity = np.identity(a_len)

    top = hstack([Q, R])
    bottom = hstack([zeros, identity])
    canonical = vstack([top, bottom])
    return Q.tocsr()


#Q = create_Q_matrix(0.25, 0.25, 0.25, 0.25)
#print(Q.shape)




mu_0 = np.ones(L**2 * 4 - 4)
for i in range(L**2 * 4 - 4):
  if i in target_indices:
    continue
  else:
    mu_0[i] = 1


mu_0 = mu_0 / np.sum(mu_0)




def create_probs(dp):      #create combinations of probabilities to try
  probs = []
  for p1 in np.arange(0, 1+dp, dp):
        for p2 in np.arange(0, 1+dp, dp):
            for p3 in np.arange(0, 1+dp, dp):
                p4 = 1 - p1 - p2 - p3
                if 0 <= p4 <= 1:
                    probs.append((p1, p2, p3, p4))
  return probs



def find_time():
  selected_probs = []
  probs = create_probs(1)    # select here how fine the control of probs is

  Q_matrices = {}
  for p in probs:
    Q_matrices[p] = create_Q_matrix(*p)


  I = identity(L**2 * 4 - 4, format='csr')
  N = I.copy()


  Q_power = Q_matrices[probs[0]]


  mu_t = np.zeros((T_max, len(mu_0)))
  mu_t[0] = mu_0
  mu_t_sums = [np.sum(mu_0)]

  for t in range(1, T_max):
    N_prev = N.copy()
    N += Q_power


    q_powers_sum = []



    q_list = []
    for p in probs:
      q_list.append(np.sum(Q_power @ Q_matrices[p]))
    best_idx = np.argmin(q_list)



    Q_power = Q_power @ Q_matrices[probs[best_idx]]


    best_p = probs[best_idx]
    selected_probs.append(best_p)


    mu_t[t] = Q_power @ mu_t[t-1]

    mu_t_sums.append(np.sum(mu_t[t]))



    delta = abs(N.sum() - N_prev.sum())
    if delta < .01:      # current form of checking convergence, could be improved possibly?
      print("max t:",t)
      break

  c = np.ones((L**2 * 4 - 4, 1))
  mfpt = N @ c
  meantime = np.sum(mfpt) / (L**2 * 4)

  #return mfpt
  return meantime, selected_probs, mu_t_sums

time, opt_p, mutsums = find_time()

print("mean time:", time)


# plot probabilities
selected_probs = np.array(opt_p)
plt.figure(figsize=(15,5))
labels = ['p1', 'p2', 'p3', 'p4']
for i in range(4):
    plt.figure(figsize=(15,5))
    plt.plot(selected_probs[:, i], label=labels[i], )
    plt.title("Optimal control protocol over time")
    plt.xlabel("Time")
    plt.ylabel("Probability")
    plt.legend()


# plot prob dcay
plt.figure(figsize=(8,5))
plt.plot(mutsums)
plt.title("Total probability in transient states")

plt.show()

############################### INDEPENDENT PROBABILITY Q-OPTIMIZATION
import numpy as np
import random
from scipy.optimize import minimize
import matplotlib.pyplot as plt
import math as m

from scipy.sparse import lil_matrix
from scipy.sparse import identity
from scipy.sparse.linalg import spsolve
from scipy.sparse import lil_matrix, csr_matrix, vstack, hstack, identity
from scipy.sparse.linalg import norm
L = 10
T_max = 1000
coordinates = np.arange(L) # creates array from 0 to L
Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows


target_loc = pos_matrix[L // 2,L // 2]

# Create transition matrix functions

def coord_to_index(i,j,k):
  M = L**2
  if k == 0:
    return j + i * L
  elif k == 1:
    return j + i * L + M
  elif k == 2:
    return j + i * L + 2 * M
  else:
    return j + i * L + 3 * M


def k_prime(k, l):
  if l == 0:
    return k
  elif l == 1:
    if k == 0:
      return 1
    elif k == 1:
      return 0
    elif k == 2:
      return 3
    else:
      return 2

  elif l == 2:
    if k ==0:
      return 2
    elif k == 1:
      return 3
    elif k == 2:
      return 1
    else:
      return 0

  elif l == 3:
    if k == 0:
      return 3
    elif k == 1:
      return 2
    elif k == 2:
      return 0
    else:
      return 1

def create_M_matrix(p1, p2, p3, p4):
    M_matrix = lil_matrix((L**2 * 4, L**2 * 4))
    probs = [p1, p2, p3, p4]
    direction_vectors = {
        0: (0, 1),   #dj = +1
        1: (0, -1),  #dj = -1
        2: (1, 0),   #di = +1
        3: (-1, 0)   #di = -1
    }
    for i in range(L):
        for j in range(L):
            for k in range(4):
                index = coord_to_index(i, j, k)   # find initial index

                #if [i, j] == target_loc:
                if [i, j] == list(target_loc):  # zero out target loc rows
                   continue
                for l in range(4):
                  prob = probs[l]       #choose probability
                  new_k = k_prime(k,l)    #find new velocities
                  di, dj = direction_vectors[new_k]     # find new direction change
                  ni, nj = (i + di) % L, (j + dj) % L   # update position
                  next_index = coord_to_index(ni, nj, new_k)    #convert back to index
                  M_matrix[index, next_index] = prob     #fill matrix with prob to go from (i, j, k) to (i', j', k')



    return M_matrix.tocsr()


target_indices = []
for k in range(4):
  target_indices.append(coord_to_index(target_loc[0], target_loc[1], k))



def create_Q_matrix(p1, p2, p3, p4):
    M = create_M_matrix(p1, p2, p3, p4)
    #for k in range(4):
     # M[coord_to_index(target_loc[0], target_loc[1], k)] = 0

    transient_indices = []
    for i in range(L**2 * 4):
      if i not in target_indices:
         transient_indices.append(i)   # find transient indices

    reordered_indices = transient_indices + target_indices
    #print(reordered_indices)

    M_reordered = M[reordered_indices, :][:, reordered_indices]
    #print(M_reordered)

    t_len = len(transient_indices)
    a_len = len(target_indices)

    Q = M_reordered[:t_len, :t_len]
    R = M_reordered[:t_len, t_len:]


    zeros = lil_matrix((a_len, t_len))

    identity = np.identity(a_len)

    top = hstack([Q, R])
    bottom = hstack([zeros, identity])
    canonical = vstack([top, bottom])
    return Q.tocsr()


#Q = create_Q_matrix(0.25, 0.25, 0.25, 0.25)
#print(Q.shape)




mu_0 = np.ones(L**2 * 4 - 4)
for i in range(L**2 * 4 - 4):
  if i in target_indices:
    continue
  else:
    mu_0[i] = 1


mu_0 = mu_0 / np.sum(mu_0)



def create_probs(dp):
  probs = []
  for p1 in np.arange(0, 1+dp, dp):
        for p2 in np.arange(0, 1+dp, dp):
            for p3 in np.arange(0, 1+dp, dp):
                p4 = 1 - p1 - p2 - p3
                if 0 <= p4 <= 1:
                  probs.append((p1, p2, p3, p4))
  return probs




'''
newT_max = 0
def find_time():
  selected_probs = []
  probs = create_probs(1)

  Q_matrices = {}
  for p in probs:
    Q_matrices[p] = create_Q_matrix(*p)


  I = identity(L**2 * 4 - 4, format='csr')
  N = I.copy()


  Q_power = Q_matrices[probs[0]]


  mu_t = np.zeros((T_max, len(mu_0)))
  mu_t[0] = mu_0
  mu_t_sums = [np.sum(mu_0)]

  for t in range(1, T_max):
    N_prev = N.copy()
    N += Q_power


    q_powers_sum = []



    q_list = []
    for p in probs:
      q_list.append(np.sum(Q_power @ Q_matrices[p]))
    best_idx = np.argmin(q_list)



    Q_power = Q_power @ Q_matrices[probs[best_idx]]


    best_p = probs[best_idx]
    selected_probs.append(best_p)


    mu_t[t] = Q_power @ mu_t[t-1]

    mu_t_sums.append(np.sum(mu_t[t]))



    delta = abs(N.sum() - N_prev.sum())
    if delta < 1e-8:      # current form of checking convergence, could be improved possibly?
      print("max t:",t)
      newT_max = t
      break

  c = np.ones((L**2 * 4 - 4, 1))
  mfpt = N @ c
  meantime = np.sum(mfpt) / (L**2 * 4)

  #return mfpt
  return meantime, selected_probs

'''



def find_time():
  selected_probs = []
  probs = create_probs(1)
  probs1 = create_probs(1)
  probs2 = create_probs(1)
  probs3 = create_probs(1)
  probs4 = create_probs(1)




  Q_matrices = {}
  for p in probs:
    Q_matrices[p] = create_Q_matrix(*p)

  Q_matrices1 = {}
  for p1 in probs1:
    Q_matrices1[p1] = create_Q_matrix(*p1)

  Q_matrices2 = {}
  for p2 in probs2:
    Q_matrices2[p2] = create_Q_matrix(*p2)

  Q_matrices3 = {}
  for p3 in probs3:
    Q_matrices3[p3] = create_Q_matrix(*p3)

  Q_matrices4 = {}
  for p4 in probs4:
    Q_matrices4[p4] = create_Q_matrix(*p4)


  I = identity(L**2 * 4 - 4, format='csr')
  N = I.copy()


  Q_power = Q_matrices[probs[0]]


  mu_t = np.zeros((T_max, len(mu_0)))
  mu_t[0] = mu_0
  mu_t_sums = [np.sum(mu_0)]

  for t in range(1, T_max):
    N_prev = N.copy()
    N += Q_power


    best_cost = 1e9
    best_Q = 0
    best_prob = None

    for p in probs:
      Q = Q_matrices[p]
      for p1 in probs1:
        Q1 = Q_matrices1[p1]
        for p2 in probs2:
          Q2 = Q_matrices2[p2]
          for p3 in probs3:
            Q3 = Q_matrices3[p3]
            for p4 in probs4:
              Q4 = Q_matrices4[p4]

              mu = Q4 @ Q3 @ Q2 @ Q1 @ Q @ mu_t[t-1]

              cost = np.sum(mu)

              if cost < best_cost:
                best_cost = cost
                best_Q = Q
                best_prob = p

    selected_probs.append(best_prob)

    Q_power = best_Q
    mu_t[t] = best_Q @ mu_t[t-1]
    mu_t_sums.append(np.sum(mu_t[t]))
    selected_probs.append(best_prob)

    N += best_Q

    delta = abs(N.sum() - N_prev.sum())
    if delta <= 0.01:
        print("max t:", t)
        break

  c = np.ones((L**2 * 4 - 4, 1))
  mfpt = N @ c
  meantime = np.sum(mfpt) / (L**2 * 4)

  time_list = []
  for t in range(1, len(mu_t_sums)):
    psi = mu_t[t - 1] - mu_t[t]
    time_list.append(t * np.sum(psi))
    meantime_theory = np.sum(time_list)

  return meantime, meantime_theory, selected_probs









time, theory_time, opt_p = find_time()

print("MFPT:", time)
print("MFPT Theory:", theory_time)

# plotting

opt_p = np.array(opt_p)  # Convert list of tuples to numpy array

'''
plt.plot(opt_p)



plt.title(f"p1 over time for a {L} by {L} lattice")
plt.xlabel("time")
plt.ylabel("p1")
'''
for i in range(4):
    plt.figure(figsize=(15,5))
    plt.plot(opt_p[:, i], color = 'green' if i ==2 else 'red', label=f'p{i+1}')
    plt.title(f"Optimal Control Policy for a {L} X {L} Lattice")
    plt.xlabel("Time")
    plt.ylabel("Probability")
    plt.legend()




plt.show()

#Stochastic sim for independent probabilites

# make sure T is same as optimize Q for independent probabilites

import numpy as np
import random
import matplotlib.pyplot as plt




N = 10  #Number of walkers
L = 10  # Length of lattice
T = len(opt_p)   #time steps
dx = 1      #step space
#p_1 = .25    # prob to go forwards
#p_2 = .25    # prob to go backwards
#p_3 = .25    # prob to turn left
#p_4 = .25    # prob to turn right

n_max = T // 4
T_extra = 0

T = T + T_extra

'''

def a(t):
  if t < 250:
    a = opt_p[t]
  elif 250 <= t < 500:
    t = t - 250
    a = opt_p[t]
  elif 500 <= t <= 250 + 250:
    t = t - 500
    a = opt_p[t]
  else:
    a = [.25, .25, .25, .25]



  return a
'''

def a(t):
  a = opt_p[t]
  return a



coordinates = np.arange(L) # creates array from 0 to L
Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows


target_loc = pos_matrix[L // 2,L // 2] # choose target location


Xmatrix = np.zeros((T, N, 2))  # (x, y) position matrix
Vmatrix = np.zeros((T, N, 2))  # (vx, vy) velocity matrix

# transformation matrices
a_matrix = np.array([[1,0],[0,1]]) # forward
b_matrix = np.array([[-1,0],[0,-1]]) # backward
c_matrix = np.array([[0,-1],[1,0]]) # left
d_matrix = np.array([[0,1],[-1,0]]) # right

# random vinitial function

def vinitial(i):   # chooses initial velocity
  r = random.choice([[0,1],[0,-1],[1,0],[-1,0]])
  return r


'''
#possible tejedor vinitial function?
def vinitial(i):
  if (i) % 4 == 0:
    return np.array([1,0])
  elif (i) % 4 == 1:
    return np.array([-1,0])
  elif (i) % 4 == 2:
    return np.array([0,1])
  else:
    return np.array([0,-1])
'''

'''
# choose initial velocity
def vinitial(i):
  if i == 0:
    d = np.array([1,0]) # +x
  elif i == 1:
    d = np.array([-1,0]) # -x
  elif i == 2:
    d = np.array([0,1]) # +y
  elif i == 3:
    d = np.array([0,-1]) # -y
  return d
'''




# velocity update version 3 (tejedor)
def v_t(prev_v, p):
    r = random.random()

    p_1, p_2, p_3, p_4 = p




    if r < p_1:
      R = a_matrix  # move forward
    elif r < p_1 + p_2:
      R = b_matrix  # move backward
    elif  r < p_1 + p_2 + p_3:
      R = c_matrix  # turn left
    else:
      R = d_matrix  # turn right

    v = R @ np.array(prev_v)
    return v




# position update function
def x_pos(pos_i):
    fpt = np.zeros(N) # intitialize first passage times array

    hit_target = np.zeros(N, dtype=bool)
    #avg_pos_per = np.zeros(T)
    for n in range(N):
        x = np.array(pos_i)
        Xmatrix[0, n] = x # set initial position

        v = np.array(vinitial(0))
        Vmatrix[0, n] = v #initialize initial velocity

        #avg_pos_per[0] = x
        for t in range(1, T):

            p = a(t)

            v = np.array(v_t(Vmatrix[t-1,n], p)) #assign velocities
            Vmatrix[t, n] = v

            step = v * dx

            x = x + step # position update
            x = x % L # boundary condition

            Xmatrix[t, n] = x # assign new positions

            #avg_pos_per[t] = x
            if np.array_equal(Xmatrix[t,n], target_loc): # check to see if walker has hit target
                fpt[n] = t # fill array with first passage times
                hit_target[n] = True
                break # stop the random walk

    return fpt, hit_target








# run trajectories over all starting positions

mfpt_map = np.zeros([L, L])
all_fpt = []  # initialize list for all FPTs
fptpos = np.zeros([N, L, L])  # store FPTs for each walker at each initial position



transient_count = np.zeros(T)
hit_counter = 0  # total walkers that reached the target

for i in range(L):
    for j in range(L):
        start_pos = pos_matrix[i, j]
        if np.array_equal(start_pos, target_loc):
            continue

        fpt, hit_target = x_pos(start_pos)

        all_fpt.extend(fpt)

        for n in range(N):
            if hit_target[n]:
                hit_counter += 1

            t_hit = int(fpt[n]) if fpt[n] > 0 else T
            transient_count[:t_hit] += 1



total_walkers = N * (L**2 - 1)  # excluding the target
transient_prob_ind_p = transient_count / total_walkers



MFPT = np.mean(all_fpt) #calculate mean first passage time over all positions and walkers


#print(f"MFPT: {MFPT}")
#print(f"{len(all_fpt)} out of {N * (L**2 - 4)} walkers found target")

print("MFPT:", MFPT)
print(f"{hit_counter} out of {total_walkers} walkers found target")





#test plot
plt.figure(figsize=(8, 5))
plt.plot(transient_prob_ind_p, label="Fraction of walkers in transient states")
plt.title("Probability of being in transient states for indie probs")
plt.legend()


plt.show()

#Stochastic sim for simple RW

# make sure T is same as optimize Q

import numpy as np
import random
import matplotlib.pyplot as plt




N = 10  #Number of walkers
L = 10   # Length of lattice
T = 2000   #time steps
dx = 1      #step space
#p_1 = .25    # prob to go forwards
#p_2 = .25    # prob to go backwards
#p_3 = .25    # prob to turn left
#p_4 = .25    # prob to turn right

n_max = T // 4

def a(t):

  a = .25

  return a




coordinates = np.arange(L) # creates array from 0 to L
Y, X = np.meshgrid(coordinates, coordinates) # creates 2D lattice grid L X L
pos_matrix = np.stack((X, Y), axis=-1) # L y columns, L x rows


target_loc = pos_matrix[L // 2,L // 2] # choose target location


Xmatrix = np.zeros((T, N, 2))  # (x, y) position matrix
Vmatrix = np.zeros((T, N, 2))  # (vx, vy) velocity matrix

# transformation matrices
a_matrix = np.array([[1,0],[0,1]]) # forward
b_matrix = np.array([[-1,0],[0,-1]]) # backward
c_matrix = np.array([[0,-1],[1,0]]) # left
d_matrix = np.array([[0,1],[-1,0]]) # right

# random vinitial function

def vinitial(i):   # chooses initial velocity
  r = random.choice([[0,1],[0,-1],[1,0],[-1,0]])
  return r


'''
#possible tejedor vinitial function?
def vinitial(i):
  if (i) % 4 == 0:
    return np.array([1,0])
  elif (i) % 4 == 1:
    return np.array([-1,0])
  elif (i) % 4 == 2:
    return np.array([0,1])
  else:
    return np.array([0,-1])
'''

'''
# choose initial velocity
def vinitial(i):
  if i == 0:
    d = np.array([1,0]) # +x
  elif i == 1:
    d = np.array([-1,0]) # -x
  elif i == 2:
    d = np.array([0,1]) # +y
  elif i == 3:
    d = np.array([0,-1]) # -y
  return d
'''




# velocity update version 3 (tejedor)
def v_t(prev_v, p_1):
    r = random.random()

    p_2 = (1 - p_1)/3
    p_3 = p_2



    if r < p_1:
      R = a_matrix  # move forward
    elif r < p_1 + p_2:
      R = b_matrix  # move backward
    elif  r < p_1 + p_2 + p_3:
      R = c_matrix  # turn left
    else:
      R = d_matrix  # turn right

    v = R @ np.array(prev_v)
    return v




# position update function
def x_pos(pos_i):
    fpt = np.zeros(N) # intitialize first passage times array

    hit_target = np.zeros(N, dtype=bool)
    #avg_pos_per = np.zeros(T)
    for n in range(N):
        x = np.array(pos_i)
        Xmatrix[0, n] = x # set initial position

        v = np.array(vinitial(0))
        Vmatrix[0, n] = v #initialize initial velocity

        #avg_pos_per[0] = x
        for t in range(1, T):

            p1 = a(t)

            v = np.array(v_t(Vmatrix[t-1,n], p1)) #assign velocities
            Vmatrix[t, n] = v

            step = v * dx

            x = x + step # position update
            x = x % L # boundary condition

            Xmatrix[t, n] = x # assign new positions

            #avg_pos_per[t] = x
            if np.array_equal(Xmatrix[t,n], target_loc): # check to see if walker has hit target
                fpt[n] = t # fill array with first passage times
                hit_target[n] = True
                break # stop the random walk

    return fpt, hit_target








# run trajectories over all starting positions

mfpt_map = np.zeros([L, L])
all_fpt = []  # initialize list for all FPTs
fptpos = np.zeros([N, L, L])  # store FPTs for each walker at each initial position



transient_count = np.zeros(T)
hit_counter = 0  # total walkers that reached the target

for i in range(L):
    for j in range(L):
        start_pos = pos_matrix[i, j]
        if np.array_equal(start_pos, target_loc):
            continue

        fpt, hit_target = x_pos(start_pos)

        all_fpt.extend(fpt)

        for n in range(N):
            if hit_target[n]:
                hit_counter += 1

            t_hit = int(fpt[n]) if fpt[n] > 0 else T
            transient_count[:t_hit] += 1



total_walkers = N * (L**2 - 1)  # excluding the target
transient_prob_simple = transient_count / total_walkers



MFPT = np.mean(all_fpt) #calculate mean first passage time over all positions and walkers


#print(f"MFPT: {MFPT}")
#print(f"{len(all_fpt)} out of {N * (L**2 - 4)} walkers found target")

print("MFPT:", MFPT)
print(f"{hit_counter} out of {total_walkers} walkers found target")





#test plot
plt.figure(figsize=(8, 5))

plt.plot(transient_prob_simple, label="Simple Random Walk")
'''
plt.plot(transient_prob_static, label="Optimal Static p1")

plt.plot(transient_prob, label = "Optimal Constrained Probabilities (p2 = p3 = p4)")
'''
plt.plot(transient_prob_ind_p, label = "Optimal Independent Probabilities")

#plt.plot(probmass, label = "State-Dependent MDP, (lower bound)")

plt.title(f"Probability to be in a Transient State For {L} X {L} Lattice")
plt.xlabel("Time")
plt.ylabel("Probability")
plt.legend()


plt.show()