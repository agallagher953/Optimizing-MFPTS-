# -*- coding: utf-8 -*-
"""PRW 2D Lattice with time varying control.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WPOVYy3SVR3Zl_8H_yoHNolj1ObYxsWr
"""

import numpy as np
import random
import matplotlib.pyplot as plt


N = 10000 #Number of walkers
L = 100   #Total space
T = 50    #time steps
x_0 = 50   #Initial position
dx = 1      #step space
#a = .5      # persistence level
p_1 = .25   #prob to go forward
p_2 = .25   # prob to go backwards
p_3 = .25   # prob to turn left
p_4 = .25   # prob to turn right


def a(t):
  a = ((1 + t)/(2 + t))**2
  return a




Xmatrix = np.zeros((T, N, 2))  # (x, y) position matrix
Vmatrix = np.zeros((T, N, 2))  # (vx, vy) velocity matrix

# transformation matrices
a_matrix = [[1,0],[0,1]]

b_matrix = [[-1,0],[0,-1]]

c_matrix = [[0,-1],[1,0]]

d_matrix = [[0,1],[-1,0]]





def vinitial():   # chooses initial velocity
  r = np.array(random.choice([[0,1],[0,-1],[1,0],[-1,0]]))

  return r

# version 1
'''
def v_t(prev_v):      # velocity update function
  r = random.random()
  if r < a:
    return np.array(prev_v)
  else:
    return np.array(random.choice([[1,0],[-1,0],[0,1],[0,-1]]))
'''

# version 2
'''
def v_t(prev_v):
  r = random.random()
  prev_v = prev_v.tolist()
  #create orthogonal directions
  if prev_v == [1,0] or prev_v == [-1,0]:
    v = random.choice([[0,1],[0,-1]])
  else:
    v = random.choice([[1,0],[-1,0]])
  #persistence
  if r < a:
    return np.array(prev_v)     # go forward
  else:
    r2 = random.random()
    if r2 < p_2:        # decide to go backwards or turn
      v = np.array([-prev_v[0], -prev_v[1]])    #backwards
    else:
      v = np.array(v)     # turn orthogonally
    return np.array(v)
'''

# version 3 (tejedor)

def v_t(prev_v, p_1):
    r = random.random()

    p_2 = (1 - p_1)/3
    p_3 = p_2



    if r < p_1:
      R = a_matrix
    elif r < p_1 + p_2:
      R = b_matrix
    elif  r < p_1 + p_2 + p_3:
      R = c_matrix
    else:
      R = d_matrix


    v = R @ np.array(prev_v)
    v = np.array(v)
    return v














def x_pos():
    for n in range(N):
        x = np.array([x_0, x_0])
        Xmatrix[0, n] = x # set initial position

        v = np.array(vinitial())
        Vmatrix[0, n] = v #initialize initial velocity

        for t in range(1, T):


            p1 = a(t)

            v = np.array(v_t(Vmatrix[t-1,n], p1)) #assign velocities
            Vmatrix[t, n] = v

            step = v * dx

            x = x + step # position update


            x = x % L # boundary condition

            Xmatrix[t, n] = x # assign new positions
    return Xmatrix


Xmatrix = x_pos() # call function/fill matrix

fig, (plot1, plot2) = plt.subplots(1, 2, figsize=(15, 4)) # subplots



#trajectory plots


for n in range(N):
    plot1.plot(Xmatrix[:, n, 0], Xmatrix[:, n, 1])
plot1.grid(True)




#Histogram
t = T - 1
pos_t_x = Xmatrix[t,:,0]
pos_t_y = Xmatrix[t,:,1]
plot2.set_xlim([-L/2, L/2])
plot2.set_ylim([-L/2, L/2])
plot2.hist2d(pos_t_x,pos_t_y ,bins=25 , density = True)





fig, (plot3, plot4) = plt.subplots(1, 2, figsize=(15, 4)) # 2nd set of subplots
# mean
mean = np.mean(Xmatrix, axis=1)

plot3.plot(range(T), mean, color='black', linewidth=2)
plot3.set_xlabel("Time (t)")
plot3.set_ylabel("Mean")


# 2nd moment
scnd_moment = np.mean(Xmatrix**2, axis = 1)

plt.figure()
plt.xlabel("Time (t))")
plt.ylabel("2nd moment")
plt.plot(range(T), scnd_moment, color='black', linewidth=2)

#variance

#var = np.var(Xmatrix, axis=1)
var = scnd_moment - mean**2
var_total = var[:, 0] + var[:, 1]
plot4.plot(range(T), var_total, color='black', linewidth=2)
plot4.set_xlabel("Time (t)")
plot4.set_ylabel("Variance")

#theoretical variance for normal walk (a = .5)
Tvar = []

for i in range(1,T):
  TheVar =   dx**2 * i
  Tvar.append(TheVar)


plot4.plot(range(T-1), Tvar, color='red', linewidth=2)



plt.show()